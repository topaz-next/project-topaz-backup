@@ -30,32 +30,32 @@
 /// @class dtQueryFilter
 ///
 /// <b>The Default Implementation</b>
-/// 
+///
 /// At construction: All area costs default to 1.0.  All flags are included
 /// and none are excluded.
-/// 
+///
 /// If a polygon has both an include and an exclude flag, it will be excluded.
-/// 
-/// The way filtering works, a navigation mesh polygon must have at least one flag 
+///
+/// The way filtering works, a navigation mesh polygon must have at least one flag
 /// set to ever be considered by a query. So a polygon with no flags will never
 /// be considered.
 ///
 /// Setting the include flags to 0 will result in all polygons being excluded.
 ///
 /// <b>Custom Implementations</b>
-/// 
+///
 /// DT_VIRTUAL_QUERYFILTER must be defined in order to extend this class.
-/// 
-/// Implement a custom query filter by overriding the virtual passFilter() 
-/// and getCost() functions. If this is done, both functions should be as 
-/// fast as possible. Use cached local copies of data rather than accessing 
+///
+/// Implement a custom query filter by overriding the virtual passFilter()
+/// and getCost() functions. If this is done, both functions should be as
+/// fast as possible. Use cached local copies of data rather than accessing
 /// your own objects where possible.
-/// 
-/// Custom implementations do not need to adhere to the flags or cost logic 
-/// used by the default implementation.  
-/// 
+///
+/// Custom implementations do not need to adhere to the flags or cost logic
+/// used by the default implementation.
+///
 /// In order for A* searches to work properly, the cost should be proportional to
-/// the travel distance. Implementing a cost modifier less than 1.0 is likely 
+/// the travel distance. Implementing a cost modifier less than 1.0 is likely
 /// to lead to problems during pathfinding.
 ///
 /// @see dtNavMeshQuery
@@ -98,8 +98,8 @@ inline float dtQueryFilter::getCost(const float* pa, const float* pb,
 {
 	return dtVdist(pa, pb) * m_areaCost[curPoly->getArea()];
 }
-#endif	
-	
+#endif
+
 static const float H_SCALE = 0.999f; // Search heuristic scale.
 
 
@@ -121,15 +121,15 @@ void dtFreeNavMeshQuery(dtNavMeshQuery* navmesh)
 
 /// @class dtNavMeshQuery
 ///
-/// For methods that support undersized buffers, if the buffer is too small 
-/// to hold the entire result set the return status of the method will include 
+/// For methods that support undersized buffers, if the buffer is too small
+/// to hold the entire result set the return status of the method will include
 /// the #DT_BUFFER_TOO_SMALL flag.
 ///
 /// Constant member functions can be used by multiple clients without side
 /// effects. (E.g. No change to the closed list. No impact on an in-progress
 /// sliced path query. Etc.)
-/// 
-/// Walls and portals: A @e wall is a polygon segment that is 
+///
+/// Walls and portals: A @e wall is a polygon segment that is
 /// considered impassable. A @e portal is a passable segment between polygons.
 /// A portal may be treated as a wall based on the dtQueryFilter used for a query.
 ///
@@ -157,7 +157,7 @@ dtNavMeshQuery::~dtNavMeshQuery()
 	dtFree(m_openList);
 }
 
-/// @par 
+/// @par
 ///
 /// Must be the first function called after construction, before other
 /// functions are used.
@@ -166,7 +166,7 @@ dtNavMeshQuery::~dtNavMeshQuery()
 dtStatus dtNavMeshQuery::init(const dtNavMesh* nav, const int maxNodes)
 {
 	m_nav = nav;
-	
+
 	if (!m_nodePool || m_nodePool->getMaxNodes() < maxNodes)
 	{
 		if (m_nodePool)
@@ -183,7 +183,7 @@ dtStatus dtNavMeshQuery::init(const dtNavMesh* nav, const int maxNodes)
 	{
 		m_nodePool->clear();
 	}
-	
+
 	if (!m_tinyNodePool)
 	{
 		m_tinyNodePool = new (dtAlloc(sizeof(dtNodePool), DT_ALLOC_PERM)) dtNodePool(64, 32);
@@ -194,7 +194,7 @@ dtStatus dtNavMeshQuery::init(const dtNavMesh* nav, const int maxNodes)
 	{
 		m_tinyNodePool->clear();
 	}
-	
+
 	// TODO: check the open list size too.
 	if (!m_openList || m_openList->getCapacity() < maxNodes)
 	{
@@ -212,23 +212,23 @@ dtStatus dtNavMeshQuery::init(const dtNavMesh* nav, const int maxNodes)
 	{
 		m_openList->clear();
 	}
-	
+
 	return DT_SUCCESS;
 }
 
 dtStatus dtNavMeshQuery::findRandomPoint(const dtQueryFilter* filter, float (*frand)(),
 										 dtPolyRef* randomRef, float* randomPt) const
 {
 	dtAssert(m_nav);
-	
+
 	// Randomly pick one tile. Assume that all tiles cover roughly the same area.
 	const dtMeshTile* tile = 0;
 	float tsum = 0.0f;
 	for (int i = 0; i < m_nav->getMaxTiles(); i++)
 	{
 		const dtMeshTile* t = m_nav->getTile(i);
 		if (!t || !t->header) continue;
-		
+
 		// Choose random tile using reservoi sampling.
 		const float area = 1.0f; // Could be tile area too.
 		tsum += area;
@@ -275,7 +275,7 @@ dtStatus dtNavMeshQuery::findRandomPoint(const dtQueryFilter* filter, float (*fr
 			polyRef = ref;
 		}
 	}
-	
+
 	if (!poly)
 		return DT_FAILURE;
 
@@ -289,19 +289,19 @@ dtStatus dtNavMeshQuery::findRandomPoint(const dtQueryFilter* filter, float (*fr
 		v = &tile->verts[poly->verts[j]*3];
 		dtVcopy(&verts[j*3],v);
 	}
-	
+
 	const float s = frand();
 	const float t = frand();
-	
+
 	float pt[3];
 	dtRandomPointInConvexPoly(verts, poly->vertCount, areas, s, t, pt);
-	
+
 	float h = 0.0f;
 	dtStatus status = getPolyHeight(polyRef, pt, &h);
 	if (dtStatusFailed(status))
 		return status;
 	pt[1] = h;
-	
+
 	dtVcopy(randomPt, pt);
 	*randomRef = polyRef;
 
@@ -315,20 +315,20 @@ dtStatus dtNavMeshQuery::findRandomPointAroundCircle(dtPolyRef startRef, const f
 	dtAssert(m_nav);
 	dtAssert(m_nodePool);
 	dtAssert(m_openList);
-	
+
 	// Validate input
 	if (!startRef || !m_nav->isValidPolyRef(startRef))
 		return DT_FAILURE | DT_INVALID_PARAM;
-	
+
 	const dtMeshTile* startTile = 0;
 	const dtPoly* startPoly = 0;
 	m_nav->getTileAndPolyByRefUnsafe(startRef, &startTile, &startPoly);
 	if (!filter->passFilter(startRef, startTile, startPoly))
 		return DT_FAILURE | DT_INVALID_PARAM;
-	
+
 	m_nodePool->clear();
 	m_openList->clear();
-	
+
 	dtNode* startNode = m_nodePool->getNode(startRef);
 	dtVcopy(startNode->pos, centerPos);
 	startNode->pidx = 0;
@@ -337,9 +337,9 @@ dtStatus dtNavMeshQuery::findRandomPointAroundCircle(dtPolyRef startRef, const f
 	startNode->id = startRef;
 	startNode->flags = DT_NODE_OPEN;
 	m_openList->push(startNode);
-	
+
 	dtStatus status = DT_SUCCESS;
-	
+
 	const float radiusSqr = dtSqr(maxRadius);
 	float areaSum = 0.0f;
 
@@ -352,7 +352,7 @@ dtStatus dtNavMeshQuery::findRandomPointAroundCircle(dtPolyRef startRef, const f
 		dtNode* bestNode = m_openList->pop();
 		bestNode->flags &= ~DT_NODE_OPEN;
 		bestNode->flags |= DT_NODE_CLOSED;
-		
+
 		// Get poly and tile.
 		// The API input has been cheked already, skip checking internal data.
 		const dtPolyRef bestRef = bestNode->id;
@@ -382,8 +382,8 @@ dtStatus dtNavMeshQuery::findRandomPointAroundCircle(dtPolyRef startRef, const f
 				randomPolyRef = bestRef;
 			}
 		}
-		
-		
+
+
 		// Get parent poly and tile.
 		dtPolyRef parentRef = 0;
 		const dtMeshTile* parentTile = 0;
@@ -392,60 +392,60 @@ dtStatus dtNavMeshQuery::findRandomPointAroundCircle(dtPolyRef startRef, const f
 			parentRef = m_nodePool->getNodeAtIdx(bestNode->pidx)->id;
 		if (parentRef)
 			m_nav->getTileAndPolyByRefUnsafe(parentRef, &parentTile, &parentPoly);
-		
+
 		for (unsigned int i = bestPoly->firstLink; i != DT_NULL_LINK; i = bestTile->links[i].next)
 		{
 			const dtLink* link = &bestTile->links[i];
 			dtPolyRef neighbourRef = link->ref;
 			// Skip invalid neighbours and do not follow back to parent.
 			if (!neighbourRef || neighbourRef == parentRef)
 				continue;
-			
+
 			// Expand to neighbour
 			const dtMeshTile* neighbourTile = 0;
 			const dtPoly* neighbourPoly = 0;
 			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);
-			
+
 			// Do not advance if the polygon is excluded by the filter.
 			if (!filter->passFilter(neighbourRef, neighbourTile, neighbourPoly))
 				continue;
-			
+
 			// Find edge and calc distance to the edge.
 			float va[3], vb[3];
 			if (!getPortalPoints(bestRef, bestPoly, bestTile, neighbourRef, neighbourPoly, neighbourTile, va, vb))
 				continue;
-			
+
 			// If the circle is not touching the next polygon, skip it.
 			float tseg;
 			float distSqr = dtDistancePtSegSqr2D(centerPos, va, vb, tseg);
 			if (distSqr > radiusSqr)
 				continue;
-			
+
 			dtNode* neighbourNode = m_nodePool->getNode(neighbourRef);
 			if (!neighbourNode)
 			{
 				status |= DT_OUT_OF_NODES;
 				continue;
 			}
-			
+
 			if (neighbourNode->flags & DT_NODE_CLOSED)
 				continue;
-			
+
 			// Cost
 			if (neighbourNode->flags == 0)
 				dtVlerp(neighbourNode->pos, va, vb, 0.5f);
-			
+
 			const float total = bestNode->total + dtVdist(bestNode->pos, neighbourNode->pos);
-			
+
 			// The node is already in open list and the new result is worse, skip.
 			if ((neighbourNode->flags & DT_NODE_OPEN) && total >= neighbourNode->total)
 				continue;
-			
+
 			neighbourNode->id = neighbourRef;
 			neighbourNode->flags = (neighbourNode->flags & ~DT_NODE_CLOSED);
 			neighbourNode->pidx = m_nodePool->getNodeIdx(bestNode);
 			neighbourNode->total = total;
-			
+
 			if (neighbourNode->flags & DT_NODE_OPEN)
 			{
 				m_openList->modify(neighbourNode);
@@ -457,10 +457,10 @@ dtStatus dtNavMeshQuery::findRandomPointAroundCircle(dtPolyRef startRef, const f
 			}
 		}
 	}
-	
+
 	if (!randomPoly)
 		return DT_FAILURE;
-	
+
 	// Randomly pick point on polygon.
 	const float* v = &randomTile->verts[randomPoly->verts[0]*3];
 	float verts[3*DT_VERTS_PER_POLYGON];
@@ -471,22 +471,22 @@ dtStatus dtNavMeshQuery::findRandomPointAroundCircle(dtPolyRef startRef, const f
 		v = &randomTile->verts[randomPoly->verts[j]*3];
 		dtVcopy(&verts[j*3],v);
 	}
-	
+
 	const float s = frand();
 	const float t = frand();
-	
+
 	float pt[3];
 	dtRandomPointInConvexPoly(verts, randomPoly->vertCount, areas, s, t, pt);
-	
+
 	float h = 0.0f;
 	dtStatus stat = getPolyHeight(randomPolyRef, pt, &h);
 	if (dtStatusFailed(status))
 		return stat;
 	pt[1] = h;
-	
+
 	dtVcopy(randomPt, pt);
 	*randomRef = randomPolyRef;
-	
+
 	return DT_SUCCESS;
 }
 
@@ -510,7 +510,7 @@ dtStatus dtNavMeshQuery::closestPointOnPoly(dtPolyRef ref, const float* pos, flo
 		return DT_FAILURE | DT_INVALID_PARAM;
 	if (!tile)
 		return DT_FAILURE | DT_INVALID_PARAM;
-	
+
 	// Off-mesh connections don't have detail polygons.
 	if (poly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
 	{
@@ -529,13 +529,13 @@ dtStatus dtNavMeshQuery::closestPointOnPoly(dtPolyRef ref, const float* pos, flo
 	const dtPolyDetail* pd = &tile->detailMeshes[ip];
 
 	// Clamp point to be inside the polygon.
-	float verts[DT_VERTS_PER_POLYGON*3];	
+	float verts[DT_VERTS_PER_POLYGON*3];
 	float edged[DT_VERTS_PER_POLYGON];
 	float edget[DT_VERTS_PER_POLYGON];
 	const int nv = poly->vertCount;
 	for (int i = 0; i < nv; ++i)
 		dtVcopy(&verts[i*3], &tile->verts[poly->verts[i]*3]);
-	
+
 	dtVcopy(closest, pos);
 	if (!dtDistancePtPolyEdgesSqr(pos, verts, nv, edged, edget))
 	{
@@ -582,41 +582,41 @@ dtStatus dtNavMeshQuery::closestPointOnPoly(dtPolyRef ref, const float* pos, flo
 			break;
 		}
 	}
-	
+
 	return DT_SUCCESS;
 }
 
 /// @par
 ///
 /// Much faster than closestPointOnPoly().
 ///
-/// If the provided position lies within the polygon's xz-bounds (above or below), 
+/// If the provided position lies within the polygon's xz-bounds (above or below),
 /// then @p pos and @p closest will be equal.
 ///
 /// The height of @p closest will be the polygon boundary.  The height detail is not used.
-/// 
+///
 /// @p pos does not have to be within the bounds of the polybon or the navigation mesh.
-/// 
+///
 dtStatus dtNavMeshQuery::closestPointOnPolyBoundary(dtPolyRef ref, const float* pos, float* closest) const
 {
 	dtAssert(m_nav);
-	
+
 	const dtMeshTile* tile = 0;
 	const dtPoly* poly = 0;
 	if (dtStatusFailed(m_nav->getTileAndPolyByRef(ref, &tile, &poly)))
 		return DT_FAILURE | DT_INVALID_PARAM;
-	
+
 	// Collect vertices.
-	float verts[DT_VERTS_PER_POLYGON*3];	
+	float verts[DT_VERTS_PER_POLYGON*3];
 	float edged[DT_VERTS_PER_POLYGON];
 	float edget[DT_VERTS_PER_POLYGON];
 	int nv = 0;
 	for (int i = 0; i < (int)poly->vertCount; ++i)
 	{
 		dtVcopy(&verts[nv*3], &tile->verts[poly->verts[i]*3]);
 		nv++;
-	}		
-	
+	}
+
 	bool inside = dtDistancePtPolyEdgesSqr(pos, verts, nv, edged, edget);
 	if (inside)
 	{
@@ -640,15 +640,15 @@ dtStatus dtNavMeshQuery::closestPointOnPolyBoundary(dtPolyRef ref, const float*
 		const float* vb = &verts[((imin+1)%nv)*3];
 		dtVlerp(closest, va, vb, edget[imin]);
 	}
-	
+
 	return DT_SUCCESS;
 }
 
 /// @par
 ///
-/// Will return #DT_FAILURE if the provided position is outside the xz-bounds 
+/// Will return #DT_FAILURE if the provided position is outside the xz-bounds
 /// of the polygon.
-/// 
+///
 dtStatus dtNavMeshQuery::getPolyHeight(dtPolyRef ref, const float* pos, float* height) const
 {
 	dtAssert(m_nav);
@@ -657,7 +657,7 @@ dtStatus dtNavMeshQuery::getPolyHeight(dtPolyRef ref, const float* pos, float* h
 	const dtPoly* poly = 0;
 	if (dtStatusFailed(m_nav->getTileAndPolyByRef(ref, &tile, &poly)))
 		return DT_FAILURE | DT_INVALID_PARAM;
-	
+
 	if (poly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
 	{
 		const float* v0 = &tile->verts[poly->verts[0]*3];
@@ -693,14 +693,14 @@ dtStatus dtNavMeshQuery::getPolyHeight(dtPolyRef ref, const float* pos, float* h
 			}
 		}
 	}
-	
+
 	return DT_FAILURE | DT_INVALID_PARAM;
 }
 
-/// @par 
+/// @par
 ///
-/// @note If the search box does not intersect any polygons the search will 
-/// return #DT_SUCCESS, but @p nearestRef will be zero. So if in doubt, check 
+/// @note If the search box does not intersect any polygons the search will
+/// return #DT_SUCCESS, but @p nearestRef will be zero. So if in doubt, check
 /// @p nearestRef before using @p nearestPt.
 ///
 /// @warning This function is not suitable for large area searches.  If the search
@@ -713,14 +713,14 @@ dtStatus dtNavMeshQuery::findNearestPoly(const float* center, const float* exten
 	dtAssert(m_nav);
 
 	*nearestRef = 0;
-	
+
 	// Get nearby polygons from proximity grid.
 	const int MAX_SEARCH = 128;
 	dtPolyRef polys[MAX_SEARCH];
 	int polyCount = 0;
 	if (dtStatusFailed(queryPolygons(center, extents, filter, polys, &polyCount, MAX_SEARCH)))
 		return DT_FAILURE | DT_INVALID_PARAM;
-	
+
 	// Find nearest polygon amongst the nearby polygons.
 	dtPolyRef nearest = 0;
 	float nearestDistanceSqr = FLT_MAX;
@@ -742,13 +742,13 @@ dtStatus dtNavMeshQuery::findNearestPoly(const float* center, const float* exten
 			const dtPoly* poly = 0;
 			m_nav->getTileAndPolyByRefUnsafe(polys[i], &tile, &poly);
 			d = dtAbs(diff[1]) - tile->header->walkableClimb;
-			d = d > 0 ? d*d : 0;			
+			d = d > 0 ? d*d : 0;
 		}
 		else
 		{
 			d = dtVlenSqr(diff);
 		}
-		
+
 		if (d < nearestDistanceSqr)
 		{
 			if (nearestPt)
@@ -757,10 +757,10 @@ dtStatus dtNavMeshQuery::findNearestPoly(const float* center, const float* exten
 			nearest = ref;
 		}
 	}
-	
+
 	if (nearestRef)
 		*nearestRef = nearest;
-	
+
 	return DT_SUCCESS;
 }
 
@@ -777,7 +777,7 @@ int dtNavMeshQuery::queryPolygonsInTile(const dtMeshTile* tile, const float* qmi
 		const float* tbmin = tile->header->bmin;
 		const float* tbmax = tile->header->bmax;
 		const float qfac = tile->header->bvQuantFactor;
-		
+
 		// Calculate quantized box
 		unsigned short bmin[3], bmax[3];
 		// dtClamp query box to world box.
@@ -794,15 +794,15 @@ int dtNavMeshQuery::queryPolygonsInTile(const dtMeshTile* tile, const float* qmi
 		bmax[0] = (unsigned short)(qfac * maxx + 1) | 1;
 		bmax[1] = (unsigned short)(qfac * maxy + 1) | 1;
 		bmax[2] = (unsigned short)(qfac * maxz + 1) | 1;
-		
+
 		// Traverse tree
 		const dtPolyRef base = m_nav->getPolyRefBase(tile);
 		int n = 0;
 		while (node < end)
 		{
 			const bool overlap = dtOverlapQuantBounds(bmin, bmax, node->bmin, node->bmax);
 			const bool isLeafNode = node->i >= 0;
-			
+
 			if (isLeafNode && overlap)
 			{
 				dtPolyRef ref = base | (dtPolyRef)node->i;
@@ -812,7 +812,7 @@ int dtNavMeshQuery::queryPolygonsInTile(const dtMeshTile* tile, const float* qmi
 						polys[n++] = ref;
 				}
 			}
-			
+
 			if (overlap || isLeafNode)
 				node++;
 			else
@@ -821,7 +821,7 @@ int dtNavMeshQuery::queryPolygonsInTile(const dtMeshTile* tile, const float* qmi
 				node += escapeIndex;
 			}
 		}
-		
+
 		return n;
 	}
 	else
@@ -859,33 +859,33 @@ int dtNavMeshQuery::queryPolygonsInTile(const dtMeshTile* tile, const float* qmi
 	}
 }
 
-/// @par 
+/// @par
 ///
 /// If no polygons are found, the function will return #DT_SUCCESS with a
 /// @p polyCount of zero.
 ///
-/// If @p polys is too small to hold the entire result set, then the array will 
-/// be filled to capacity. The method of choosing which polygons from the 
+/// If @p polys is too small to hold the entire result set, then the array will
+/// be filled to capacity. The method of choosing which polygons from the
 /// full set are included in the partial result set is undefined.
 ///
 dtStatus dtNavMeshQuery::queryPolygons(const float* center, const float* extents,
 									   const dtQueryFilter* filter,
 									   dtPolyRef* polys, int* polyCount, const int maxPolys) const
 {
 	dtAssert(m_nav);
-	
+
 	float bmin[3], bmax[3];
 	dtVsub(bmin, center, extents);
 	dtVadd(bmax, center, extents);
-	
+
 	// Find tiles the query touches.
 	int minx, miny, maxx, maxy;
 	m_nav->calcTileLoc(bmin, &minx, &miny);
 	m_nav->calcTileLoc(bmax, &maxx, &maxy);
 
 	static const int MAX_NEIS = 32;
 	const dtMeshTile* neis[MAX_NEIS];
-	
+
 	int n = 0;
 	for (int y = miny; y <= maxy; ++y)
 	{
@@ -904,7 +904,7 @@ dtStatus dtNavMeshQuery::queryPolygons(const float* center, const float* extents
 		}
 	}
 	*polyCount = n;
-	
+
 	return DT_SUCCESS;
 }
 
@@ -913,10 +913,10 @@ dtStatus dtNavMeshQuery::queryPolygons(const float* center, const float* extents
 /// If the end polygon cannot be reached through the navigation graph,
 /// the last polygon in the path will be the nearest the end polygon.
 ///
-/// If the path array is to small to hold the full result, it will be filled as 
+/// If the path array is to small to hold the full result, it will be filled as
 /// far as possible from the start polygon toward the end polygon.
 ///
-/// The start and end positions are used to calculate traversal costs. 
+/// The start and end positions are used to calculate traversal costs.
 /// (The y-values impact the result.)
 ///
 dtStatus dtNavMeshQuery::findPath(dtPolyRef startRef, dtPolyRef endRef,
@@ -927,29 +927,29 @@ dtStatus dtNavMeshQuery::findPath(dtPolyRef startRef, dtPolyRef endRef,
 	dtAssert(m_nav);
 	dtAssert(m_nodePool);
 	dtAssert(m_openList);
-	
+
 	*pathCount = 0;
-	
+
 	if (!startRef || !endRef)
 		return DT_FAILURE | DT_INVALID_PARAM;
-	
+
 	if (!maxPath)
 		return DT_FAILURE | DT_INVALID_PARAM;
-	
+
 	// Validate input
 	if (!m_nav->isValidPolyRef(startRef) || !m_nav->isValidPolyRef(endRef))
 		return DT_FAILURE | DT_INVALID_PARAM;
-	
+
 	if (startRef == endRef)
 	{
 		path[0] = startRef;
 		*pathCount = 1;
 		return DT_SUCCESS;
 	}
-	
+
 	m_nodePool->clear();
 	m_openList->clear();
-	
+
 	dtNode* startNode = m_nodePool->getNode(startRef);
 	dtVcopy(startNode->pos, startPos);
 	startNode->pidx = 0;
@@ -958,33 +958,33 @@ dtStatus dtNavMeshQuery::findPath(dtPolyRef startRef, dtPolyRef endRef,
 	startNode->id = startRef;
 	startNode->flags = DT_NODE_OPEN;
 	m_openList->push(startNode);
-	
+
 	dtNode* lastBestNode = startNode;
 	float lastBestNodeCost = startNode->total;
-	
+
 	dtStatus status = DT_SUCCESS;
-	
+
 	while (!m_openList->empty())
 	{
 		// Remove node from open list and put it in closed list.
 		dtNode* bestNode = m_openList->pop();
 		bestNode->flags &= ~DT_NODE_OPEN;
 		bestNode->flags |= DT_NODE_CLOSED;
-		
+
 		// Reached the goal, stop searching.
 		if (bestNode->id == endRef)
 		{
 			lastBestNode = bestNode;
 			break;
 		}
-		
+
 		// Get current poly and tile.
 		// The API input has been cheked already, skip checking internal data.
 		const dtPolyRef bestRef = bestNode->id;
 		const dtMeshTile* bestTile = 0;
 		const dtPoly* bestPoly = 0;
 		m_nav->getTileAndPolyByRefUnsafe(bestRef, &bestTile, &bestPoly);
-		
+
 		// Get parent poly and tile.
 		dtPolyRef parentRef = 0;
 		const dtMeshTile* parentTile = 0;
@@ -993,21 +993,21 @@ dtStatus dtNavMeshQuery::findPath(dtPolyRef startRef, dtPolyRef endRef,
 			parentRef = m_nodePool->getNodeAtIdx(bestNode->pidx)->id;
 		if (parentRef)
 			m_nav->getTileAndPolyByRefUnsafe(parentRef, &parentTile, &parentPoly);
-		
+
 		for (unsigned int i = bestPoly->firstLink; i != DT_NULL_LINK; i = bestTile->links[i].next)
 		{
 			dtPolyRef neighbourRef = bestTile->links[i].ref;
-			
+
 			// Skip invalid ids and do not expand back to where we came from.
 			if (!neighbourRef || neighbourRef == parentRef)
 				continue;
-			
+
 			// Get neighbour poly and tile.
 			// The API input has been cheked already, skip checking internal data.
 			const dtMeshTile* neighbourTile = 0;
 			const dtPoly* neighbourPoly = 0;
-			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);			
-			
+			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);
+
 			if (!filter->passFilter(neighbourRef, neighbourTile, neighbourPoly))
 				continue;
 
@@ -1023,7 +1023,7 @@ dtStatus dtNavMeshQuery::findPath(dtPolyRef startRef, dtPolyRef endRef,
 				status |= DT_OUT_OF_NODES;
 				continue;
 			}
-			
+
 			// If the node is visited the first time, calculate node position.
 			if (neighbourNode->flags == 0)
 			{
@@ -1035,7 +1035,7 @@ dtStatus dtNavMeshQuery::findPath(dtPolyRef startRef, dtPolyRef endRef,
 			// Calculate cost and heuristic.
 			float cost = 0;
 			float heuristic = 0;
-			
+
 			// Special case for last node.
 			if (neighbourRef == endRef)
 			{
@@ -1048,7 +1048,7 @@ dtStatus dtNavMeshQuery::findPath(dtPolyRef startRef, dtPolyRef endRef,
 													  bestRef, bestTile, bestPoly,
 													  neighbourRef, neighbourTile, neighbourPoly,
 													  0, 0, 0);
-				
+
 				cost = bestNode->cost + curCost + endCost;
 				heuristic = 0;
 			}
@@ -1064,21 +1064,21 @@ dtStatus dtNavMeshQuery::findPath(dtPolyRef startRef, dtPolyRef endRef,
 			}
 
 			const float total = cost + heuristic;
-			
+
 			// The node is already in open list and the new result is worse, skip.
 			if ((neighbourNode->flags & DT_NODE_OPEN) && total >= neighbourNode->total)
 				continue;
 			// The node is already visited and process, and the new result is worse, skip.
 			if ((neighbourNode->flags & DT_NODE_CLOSED) && total >= neighbourNode->total)
 				continue;
-			
+
 			// Add or update the node.
 			neighbourNode->pidx = m_nodePool->getNodeIdx(bestNode);
 			neighbourNode->id = neighbourRef;
 			neighbourNode->flags = (neighbourNode->flags & ~DT_NODE_CLOSED);
 			neighbourNode->cost = cost;
 			neighbourNode->total = total;
-			
+
 			if (neighbourNode->flags & DT_NODE_OPEN)
 			{
 				// Already in open, update node location.
@@ -1090,7 +1090,7 @@ dtStatus dtNavMeshQuery::findPath(dtPolyRef startRef, dtPolyRef endRef,
 				neighbourNode->flags |= DT_NODE_OPEN;
 				m_openList->push(neighbourNode);
 			}
-			
+
 			// Update nearest node to target so far.
 			if (heuristic < lastBestNodeCost)
 			{
@@ -1099,10 +1099,10 @@ dtStatus dtNavMeshQuery::findPath(dtPolyRef startRef, dtPolyRef endRef,
 			}
 		}
 	}
-	
+
 	if (lastBestNode->id != endRef)
 		status |= DT_PARTIAL_RESULT;
-	
+
 	// Reverse the path.
 	dtNode* prev = 0;
 	dtNode* node = lastBestNode;
@@ -1114,7 +1114,7 @@ dtStatus dtNavMeshQuery::findPath(dtPolyRef startRef, dtPolyRef endRef,
 		node = next;
 	}
 	while (node);
-	
+
 	// Store path
 	node = prev;
 	int n = 0;
@@ -1129,15 +1129,15 @@ dtStatus dtNavMeshQuery::findPath(dtPolyRef startRef, dtPolyRef endRef,
 		node = m_nodePool->getNodeAtIdx(node->pidx);
 	}
 	while (node);
-	
+
 	*pathCount = n;
-	
+
 	return status;
 }
 
 /// @par
 ///
-/// @warning Calling any non-slice methods before calling finalizeSlicedFindPath() 
+/// @warning Calling any non-slice methods before calling finalizeSlicedFindPath()
 /// or finalizeSlicedFindPathPartial() may result in corrupted data!
 ///
 /// The @p filter pointer is stored and used for the duration of the sliced
@@ -1161,18 +1161,18 @@ dtStatus dtNavMeshQuery::initSlicedFindPath(dtPolyRef startRef, dtPolyRef endRef
 	m_query.filter = filter;
 	m_query.options = options;
 	m_query.raycastLimitSqr = FLT_MAX;
-	
+
 	if (!startRef || !endRef)
 		return DT_FAILURE | DT_INVALID_PARAM;
-	
+
 	// Validate input
 	if (!m_nav->isValidPolyRef(startRef) || !m_nav->isValidPolyRef(endRef))
 		return DT_FAILURE | DT_INVALID_PARAM;
 
 	// trade quality with performance?
 	if (options & DT_FINDPATH_ANY_ANGLE)
 	{
-		// limiting to several times the character radius yields nice results. It is not sensitive 
+		// limiting to several times the character radius yields nice results. It is not sensitive
 		// so it is enough to compute it from the first tile.
 		const dtMeshTile* tile = m_nav->getTileByRef(startRef);
 		float agentRadius = tile->header->walkableRadius;
@@ -1184,10 +1184,10 @@ dtStatus dtNavMeshQuery::initSlicedFindPath(dtPolyRef startRef, dtPolyRef endRef
 		m_query.status = DT_SUCCESS;
 		return DT_SUCCESS;
 	}
-	
+
 	m_nodePool->clear();
 	m_openList->clear();
-	
+
 	dtNode* startNode = m_nodePool->getNode(startRef);
 	dtVcopy(startNode->pos, startPos);
 	startNode->pidx = 0;
@@ -1196,14 +1196,14 @@ dtStatus dtNavMeshQuery::initSlicedFindPath(dtPolyRef startRef, dtPolyRef endRef
 	startNode->id = startRef;
 	startNode->flags = DT_NODE_OPEN;
 	m_openList->push(startNode);
-	
+
 	m_query.status = DT_IN_PROGRESS;
 	m_query.lastBestNode = startNode;
 	m_query.lastBestNodeCost = startNode->total;
-	
+
 	return m_query.status;
 }
-	
+
 dtStatus dtNavMeshQuery::updateSlicedFindPath(const int maxIter, int* doneIters)
 {
 	if (!dtStatusInProgress(m_query.status))
@@ -1218,17 +1218,17 @@ dtStatus dtNavMeshQuery::updateSlicedFindPath(const int maxIter, int* doneIters)
 
 	dtRaycastHit rayHit;
 	rayHit.maxPath = 0;
-		
+
 	int iter = 0;
 	while (iter < maxIter && !m_openList->empty())
 	{
 		iter++;
-		
+
 		// Remove node from open list and put it in closed list.
 		dtNode* bestNode = m_openList->pop();
 		bestNode->flags &= ~DT_NODE_OPEN;
 		bestNode->flags |= DT_NODE_CLOSED;
-		
+
 		// Reached the goal, stop searching.
 		if (bestNode->id == m_query.endRef)
 		{
@@ -1239,7 +1239,7 @@ dtStatus dtNavMeshQuery::updateSlicedFindPath(const int maxIter, int* doneIters)
 				*doneIters = iter;
 			return m_query.status;
 		}
-		
+
 		// Get current poly and tile.
 		// The API input has been cheked already, skip checking internal data.
 		const dtPolyRef bestRef = bestNode->id;
@@ -1253,7 +1253,7 @@ dtStatus dtNavMeshQuery::updateSlicedFindPath(const int maxIter, int* doneIters)
 				*doneIters = iter;
 			return m_query.status;
 		}
-		
+
 		// Get parent and grand parent poly and tile.
 		dtPolyRef parentRef = 0, grandpaRef = 0;
 		const dtMeshTile* parentTile = 0;
@@ -1286,32 +1286,32 @@ dtStatus dtNavMeshQuery::updateSlicedFindPath(const int maxIter, int* doneIters)
 			if ((parentRef != 0) && (dtVdistSqr(parentNode->pos, bestNode->pos) < m_query.raycastLimitSqr))
 				tryLOS = true;
 		}
-		
+
 		for (unsigned int i = bestPoly->firstLink; i != DT_NULL_LINK; i = bestTile->links[i].next)
 		{
 			dtPolyRef neighbourRef = bestTile->links[i].ref;
-			
+
 			// Skip invalid ids and do not expand back to where we came from.
 			if (!neighbourRef || neighbourRef == parentRef)
 				continue;
-			
+
 			// Get neighbour poly and tile.
 			// The API input has been cheked already, skip checking internal data.
 			const dtMeshTile* neighbourTile = 0;
 			const dtPoly* neighbourPoly = 0;
-			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);			
-			
+			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);
+
 			if (!m_query.filter->passFilter(neighbourRef, neighbourTile, neighbourPoly))
 				continue;
-			
+
 			// get the neighbor node
 			dtNode* neighbourNode = m_nodePool->getNode(neighbourRef, 0);
 			if (!neighbourNode)
 			{
 				m_query.status |= DT_OUT_OF_NODES;
 				continue;
 			}
-			
+
 			// do not expand to nodes that were already visited from the same parent
 			if (neighbourNode->pidx != 0 && neighbourNode->pidx == bestNode->pidx)
 				continue;
@@ -1323,11 +1323,11 @@ dtStatus dtNavMeshQuery::updateSlicedFindPath(const int maxIter, int* doneIters)
 								neighbourRef, neighbourPoly, neighbourTile,
 								neighbourNode->pos);
 			}
-			
+
 			// Calculate cost and heuristic.
 			float cost = 0;
 			float heuristic = 0;
-			
+
 			// raycast parent
 			bool foundShortCut = false;
 			rayHit.pathCost = rayHit.t = 0;
@@ -1360,24 +1360,24 @@ dtStatus dtNavMeshQuery::updateSlicedFindPath(const int maxIter, int* doneIters)
 															  bestRef, bestTile, bestPoly,
 															  neighbourRef, neighbourTile, neighbourPoly,
 															  0, 0, 0);
-				
+
 				cost = cost + endCost;
 				heuristic = 0;
 			}
 			else
 			{
 				heuristic = dtVdist(neighbourNode->pos, m_query.endPos)*H_SCALE;
 			}
-			
+
 			const float total = cost + heuristic;
-			
+
 			// The node is already in open list and the new result is worse, skip.
 			if ((neighbourNode->flags & DT_NODE_OPEN) && total >= neighbourNode->total)
 				continue;
 			// The node is already visited and process, and the new result is worse, skip.
 			if ((neighbourNode->flags & DT_NODE_CLOSED) && total >= neighbourNode->total)
 				continue;
-			
+
 			// Add or update the node.
 			neighbourNode->pidx = foundShortCut ? bestNode->pidx : m_nodePool->getNodeIdx(bestNode);
 			neighbourNode->id = neighbourRef;
@@ -1386,7 +1386,7 @@ dtStatus dtNavMeshQuery::updateSlicedFindPath(const int maxIter, int* doneIters)
 			neighbourNode->total = total;
 			if (foundShortCut)
 				neighbourNode->flags = (neighbourNode->flags | DT_NODE_PARENT_DETACHED);
-			
+
 			if (neighbourNode->flags & DT_NODE_OPEN)
 			{
 				// Already in open, update node location.
@@ -1398,7 +1398,7 @@ dtStatus dtNavMeshQuery::updateSlicedFindPath(const int maxIter, int* doneIters)
 				neighbourNode->flags |= DT_NODE_OPEN;
 				m_openList->push(neighbourNode);
 			}
-			
+
 			// Update nearest node to target so far.
 			if (heuristic < m_query.lastBestNodeCost)
 			{
@@ -1407,7 +1407,7 @@ dtStatus dtNavMeshQuery::updateSlicedFindPath(const int maxIter, int* doneIters)
 			}
 		}
 	}
-	
+
 	// Exhausted all nodes, but could not find path.
 	if (m_openList->empty())
 	{
@@ -1424,7 +1424,7 @@ dtStatus dtNavMeshQuery::updateSlicedFindPath(const int maxIter, int* doneIters)
 dtStatus dtNavMeshQuery::finalizeSlicedFindPath(dtPolyRef* path, int* pathCount, const int maxPath)
 {
 	*pathCount = 0;
-	
+
 	if (dtStatusFailed(m_query.status))
 	{
 		// Reset query.
@@ -1443,10 +1443,10 @@ dtStatus dtNavMeshQuery::finalizeSlicedFindPath(dtPolyRef* path, int* pathCount,
 	{
 		// Reverse the path.
 		dtAssert(m_query.lastBestNode);
-		
+
 		if (m_query.lastBestNode->id != m_query.endRef)
 			m_query.status |= DT_PARTIAL_RESULT;
-		
+
 		dtNode* prev = 0;
 		dtNode* node = m_query.lastBestNode;
 		int prevRay = 0;
@@ -1461,7 +1461,7 @@ dtStatus dtNavMeshQuery::finalizeSlicedFindPath(dtPolyRef* path, int* pathCount,
 			node = next;
 		}
 		while (node);
-		
+
 		// Store path
 		node = prev;
 		do
@@ -1494,36 +1494,36 @@ dtStatus dtNavMeshQuery::finalizeSlicedFindPath(dtPolyRef* path, int* pathCount,
 		}
 		while (node);
 	}
-	
+
 	const dtStatus details = m_query.status & DT_STATUS_DETAIL_MASK;
 
 	// Reset query.
 	memset(&m_query, 0, sizeof(dtQueryData));
-	
+
 	*pathCount = n;
-	
+
 	return DT_SUCCESS | details;
 }
 
 dtStatus dtNavMeshQuery::finalizeSlicedFindPathPartial(const dtPolyRef* existing, const int existingSize,
 													   dtPolyRef* path, int* pathCount, const int maxPath)
 {
 	*pathCount = 0;
-	
+
 	if (existingSize == 0)
 	{
 		return DT_FAILURE;
 	}
-	
+
 	if (dtStatusFailed(m_query.status))
 	{
 		// Reset query.
 		memset(&m_query, 0, sizeof(dtQueryData));
 		return DT_FAILURE;
 	}
-	
+
 	int n = 0;
-	
+
 	if (m_query.startRef == m_query.endRef)
 	{
 		// Special case: the search starts and ends at same poly.
@@ -1540,14 +1540,14 @@ dtStatus dtNavMeshQuery::finalizeSlicedFindPathPartial(const dtPolyRef* existing
 			if (node)
 				break;
 		}
-		
+
 		if (!node)
 		{
 			m_query.status |= DT_PARTIAL_RESULT;
 			dtAssert(m_query.lastBestNode);
 			node = m_query.lastBestNode;
 		}
-		
+
 		// Reverse the path.
 		int prevRay = 0;
 		do
@@ -1561,7 +1561,7 @@ dtStatus dtNavMeshQuery::finalizeSlicedFindPathPartial(const dtPolyRef* existing
 			node = next;
 		}
 		while (node);
-		
+
 		// Store path
 		node = prev;
 		do
@@ -1594,14 +1594,14 @@ dtStatus dtNavMeshQuery::finalizeSlicedFindPathPartial(const dtPolyRef* existing
 		}
 		while (node);
 	}
-	
+
 	const dtStatus details = m_query.status & DT_STATUS_DETAIL_MASK;
 
 	// Reset query.
 	memset(&m_query, 0, sizeof(dtQueryData));
-	
+
 	*pathCount = n;
-	
+
 	return DT_SUCCESS | details;
 }
 
@@ -1651,24 +1651,24 @@ dtStatus dtNavMeshQuery::appendPortals(const int startIdx, const int endIdx, con
 		const dtPoly* fromPoly = 0;
 		if (dtStatusFailed(m_nav->getTileAndPolyByRef(from, &fromTile, &fromPoly)))
 			return DT_FAILURE | DT_INVALID_PARAM;
-		
+
 		const dtPolyRef to = path[i+1];
 		const dtMeshTile* toTile = 0;
 		const dtPoly* toPoly = 0;
 		if (dtStatusFailed(m_nav->getTileAndPolyByRef(to, &toTile, &toPoly)))
 			return DT_FAILURE | DT_INVALID_PARAM;
-		
+
 		float left[3], right[3];
 		if (dtStatusFailed(getPortalPoints(from, fromPoly, fromTile, to, toPoly, toTile, left, right)))
 			break;
-	
+
 		if (options & DT_STRAIGHTPATH_AREA_CROSSINGS)
 		{
 			// Skip intersection if only area crossings are requested.
 			if (fromPoly->getArea() == toPoly->getArea())
 				continue;
 		}
-		
+
 		// Append intersection
 		float s,t;
 		if (dtIntersectSegSeg2D(startPos, endPos, left, right, s, t))
@@ -1687,20 +1687,20 @@ dtStatus dtNavMeshQuery::appendPortals(const int startIdx, const int endIdx, con
 }
 
 /// @par
-/// 
+///
 /// This method peforms what is often called 'string pulling'.
 ///
-/// The start position is clamped to the first polygon in the path, and the 
-/// end position is clamped to the last. So the start and end positions should 
+/// The start position is clamped to the first polygon in the path, and the
+/// end position is clamped to the last. So the start and end positions should
 /// normally be within or very near the first and last polygons respectively.
 ///
-/// The returned polygon references represent the reference id of the polygon 
-/// that is entered at the associated path position. The reference id associated 
-/// with the end point will always be zero.  This allows, for example, matching 
+/// The returned polygon references represent the reference id of the polygon
+/// that is entered at the associated path position. The reference id associated
+/// with the end point will always be zero.  This allows, for example, matching
 /// off-mesh link points to their representative polygons.
 ///
-/// If the provided result buffers are too small for the entire result set, 
-/// they will be filled as far as possible from the start toward the end 
+/// If the provided result buffers are too small for the entire result set,
+/// they will be filled as far as possible from the start toward the end
 /// position.
 ///
 dtStatus dtNavMeshQuery::findStraightPath(const float* startPos, const float* endPos,
@@ -1709,17 +1709,17 @@ dtStatus dtNavMeshQuery::findStraightPath(const float* startPos, const float* en
 										  int* straightPathCount, const int maxStraightPath, const int options) const
 {
 	dtAssert(m_nav);
-	
+
 	*straightPathCount = 0;
-	
+
 	if (!maxStraightPath)
 		return DT_FAILURE | DT_INVALID_PARAM;
-	
+
 	if (!path[0])
 		return DT_FAILURE | DT_INVALID_PARAM;
-	
+
 	dtStatus stat = 0;
-	
+
 	// TODO: Should this be callers responsibility?
 	float closestStartPos[3];
 	if (dtStatusFailed(closestPointOnPolyBoundary(path[0], startPos, closestStartPos)))
@@ -1728,14 +1728,14 @@ dtStatus dtNavMeshQuery::findStraightPath(const float* startPos, const float* en
 	float closestEndPos[3];
 	if (dtStatusFailed(closestPointOnPolyBoundary(path[pathSize-1], endPos, closestEndPos)))
 		return DT_FAILURE | DT_INVALID_PARAM;
-	
+
 	// Add start point.
 	stat = appendVertex(closestStartPos, DT_STRAIGHTPATH_START, path[0],
 						straightPath, straightPathFlags, straightPathRefs,
 						straightPathCount, maxStraightPath);
 	if (stat != DT_IN_PROGRESS)
 		return stat;
-	
+
 	if (pathSize > 1)
 	{
 		float portalApex[3], portalLeft[3], portalRight[3];
@@ -1745,26 +1745,26 @@ dtStatus dtNavMeshQuery::findStraightPath(const float* startPos, const float* en
 		int apexIndex = 0;
 		int leftIndex = 0;
 		int rightIndex = 0;
-		
+
 		unsigned char leftPolyType = 0;
 		unsigned char rightPolyType = 0;
-		
+
 		dtPolyRef leftPolyRef = path[0];
 		dtPolyRef rightPolyRef = path[0];
-		
+
 		for (int i = 0; i < pathSize; ++i)
 		{
 			float left[3], right[3];
 			unsigned char fromType, toType;
-			
+
 			if (i+1 < pathSize)
 			{
 				// Next portal.
 				if (dtStatusFailed(getPortalPoints(path[i], path[i+1], left, right, fromType, toType)))
 				{
 					// Failed to get portal points, in practice this means that path[i+1] is invalid polygon.
 					// Clamp the end point to path[i], and return the path so far.
-					
+
 					if (dtStatusFailed(closestPointOnPolyBoundary(path[i], endPos, closestEndPos)))
 					{
 						// This should only happen when the first polygon is invalid.
@@ -1782,10 +1782,10 @@ dtStatus dtNavMeshQuery::findStraightPath(const float* startPos, const float* en
 					stat = appendVertex(closestEndPos, 0, path[i],
 										straightPath, straightPathFlags, straightPathRefs,
 										straightPathCount, maxStraightPath);
-					
+
 					return DT_SUCCESS | DT_PARTIAL_RESULT | ((*straightPathCount >= maxStraightPath) ? DT_BUFFER_TOO_SMALL : 0);
 				}
-				
+
 				// If starting really close the portal, advance.
 				if (i == 0)
 				{
@@ -1799,10 +1799,10 @@ dtStatus dtNavMeshQuery::findStraightPath(const float* startPos, const float* en
 				// End of the path.
 				dtVcopy(left, closestEndPos);
 				dtVcopy(right, closestEndPos);
-				
+
 				fromType = toType = DT_POLYTYPE_GROUND;
 			}
-			
+
 			// Right vertex.
 			if (dtTriArea2D(portalApex, portalRight, right) <= 0.0f)
 			{
@@ -1822,38 +1822,38 @@ dtStatus dtNavMeshQuery::findStraightPath(const float* startPos, const float* en
 											 straightPath, straightPathFlags, straightPathRefs,
 											 straightPathCount, maxStraightPath, options);
 						if (stat != DT_IN_PROGRESS)
-							return stat;					
+							return stat;
 					}
-				
+
 					dtVcopy(portalApex, portalLeft);
 					apexIndex = leftIndex;
-					
+
 					unsigned char flags = 0;
 					if (!leftPolyRef)
 						flags = DT_STRAIGHTPATH_END;
 					else if (leftPolyType == DT_POLYTYPE_OFFMESH_CONNECTION)
 						flags = DT_STRAIGHTPATH_OFFMESH_CONNECTION;
 					dtPolyRef ref = leftPolyRef;
-					
+
 					// Append or update vertex
 					stat = appendVertex(portalApex, flags, ref,
 										straightPath, straightPathFlags, straightPathRefs,
 										straightPathCount, maxStraightPath);
 					if (stat != DT_IN_PROGRESS)
 						return stat;
-					
+
 					dtVcopy(portalLeft, portalApex);
 					dtVcopy(portalRight, portalApex);
 					leftIndex = apexIndex;
 					rightIndex = apexIndex;
-					
+
 					// Restart
 					i = apexIndex;
-					
+
 					continue;
 				}
 			}
-			
+
 			// Left vertex.
 			if (dtTriArea2D(portalApex, portalLeft, left) >= 0.0f)
 			{
@@ -1878,7 +1878,7 @@ dtStatus dtNavMeshQuery::findStraightPath(const float* startPos, const float* en
 
 					dtVcopy(portalApex, portalRight);
 					apexIndex = rightIndex;
-					
+
 					unsigned char flags = 0;
 					if (!rightPolyRef)
 						flags = DT_STRAIGHTPATH_END;
@@ -1892,15 +1892,15 @@ dtStatus dtNavMeshQuery::findStraightPath(const float* startPos, const float* en
 										straightPathCount, maxStraightPath);
 					if (stat != DT_IN_PROGRESS)
 						return stat;
-					
+
 					dtVcopy(portalLeft, portalApex);
 					dtVcopy(portalRight, portalApex);
 					leftIndex = apexIndex;
 					rightIndex = apexIndex;
-					
+
 					// Restart
 					i = apexIndex;
-					
+
 					continue;
 				}
 			}
@@ -1920,28 +1920,28 @@ dtStatus dtNavMeshQuery::findStraightPath(const float* startPos, const float* en
 	stat = appendVertex(closestEndPos, DT_STRAIGHTPATH_END, 0,
 						straightPath, straightPathFlags, straightPathRefs,
 						straightPathCount, maxStraightPath);
-	
+
 	return DT_SUCCESS | ((*straightPathCount >= maxStraightPath) ? DT_BUFFER_TOO_SMALL : 0);
 }
 
 /// @par
 ///
-/// This method is optimized for small delta movement and a small number of 
-/// polygons. If used for too great a distance, the result set will form an 
+/// This method is optimized for small delta movement and a small number of
+/// polygons. If used for too great a distance, the result set will form an
 /// incomplete path.
 ///
-/// @p resultPos will equal the @p endPos if the end is reached. 
+/// @p resultPos will equal the @p endPos if the end is reached.
 /// Otherwise the closest reachable position will be returned.
-/// 
-/// @p resultPos is not projected onto the surface of the navigation 
+///
+/// @p resultPos is not projected onto the surface of the navigation
 /// mesh. Use #getPolyHeight if this is needed.
 ///
-/// This method treats the end position in the same manner as 
-/// the #raycast method. (As a 2D point.) See that method's documentation 
+/// This method treats the end position in the same manner as
+/// the #raycast method. (As a 2D point.) See that method's documentation
 /// for details.
-/// 
-/// If the @p visited array is too small to hold the entire result set, it will 
-/// be filled as far as possible from the start position toward the end 
+///
+/// If the @p visited array is too small to hold the entire result set, it will
+/// be filled as far as possible from the start position toward the end
 /// position.
 ///
 dtStatus dtNavMeshQuery::moveAlongSurface(dtPolyRef startRef, const float* startPos, const float* endPos,
@@ -1952,77 +1952,77 @@ dtStatus dtNavMeshQuery::moveAlongSurface(dtPolyRef startRef, const float* start
 	dtAssert(m_tinyNodePool);
 
 	*visitedCount = 0;
-	
+
 	// Validate input
 	if (!startRef)
 		return DT_FAILURE | DT_INVALID_PARAM;
 	if (!m_nav->isValidPolyRef(startRef))
 		return DT_FAILURE | DT_INVALID_PARAM;
-	
+
 	dtStatus status = DT_SUCCESS;
-	
+
 	static const int MAX_STACK = 48;
 	dtNode* stack[MAX_STACK];
 	int nstack = 0;
-	
+
 	m_tinyNodePool->clear();
-	
+
 	dtNode* startNode = m_tinyNodePool->getNode(startRef);
 	startNode->pidx = 0;
 	startNode->cost = 0;
 	startNode->total = 0;
 	startNode->id = startRef;
 	startNode->flags = DT_NODE_CLOSED;
 	stack[nstack++] = startNode;
-	
+
 	float bestPos[3];
 	float bestDist = FLT_MAX;
 	dtNode* bestNode = 0;
 	dtVcopy(bestPos, startPos);
-	
+
 	// Search constraints
 	float searchPos[3], searchRadSqr;
 	dtVlerp(searchPos, startPos, endPos, 0.5f);
 	searchRadSqr = dtSqr(dtVdist(startPos, endPos)/2.0f + 0.001f);
-	
+
 	float verts[DT_VERTS_PER_POLYGON*3];
-	
+
 	while (nstack)
 	{
 		// Pop front.
 		dtNode* curNode = stack[0];
 		for (int i = 0; i < nstack-1; ++i)
 			stack[i] = stack[i+1];
 		nstack--;
-		
+
 		// Get poly and tile.
 		// The API input has been cheked already, skip checking internal data.
 		const dtPolyRef curRef = curNode->id;
 		const dtMeshTile* curTile = 0;
 		const dtPoly* curPoly = 0;
-		m_nav->getTileAndPolyByRefUnsafe(curRef, &curTile, &curPoly);			
-		
+		m_nav->getTileAndPolyByRefUnsafe(curRef, &curTile, &curPoly);
+
 		// Collect vertices.
 		const int nverts = curPoly->vertCount;
 		for (int i = 0; i < nverts; ++i)
 			dtVcopy(&verts[i*3], &curTile->verts[curPoly->verts[i]*3]);
-		
+
 		// If target is inside the poly, stop search.
 		if (dtPointInPolygon(endPos, verts, nverts))
 		{
 			bestNode = curNode;
 			dtVcopy(bestPos, endPos);
 			break;
 		}
-		
+
 		// Find wall edges and find nearest point inside the walls.
 		for (int i = 0, j = (int)curPoly->vertCount-1; i < (int)curPoly->vertCount; j = i++)
 		{
 			// Find links to neighbours.
 			static const int MAX_NEIS = 8;
 			int nneis = 0;
 			dtPolyRef neis[MAX_NEIS];
-			
+
 			if (curPoly->neis[j] & DT_EXT_LINK)
 			{
 				// Tile border.
@@ -2055,7 +2055,7 @@ dtStatus dtNavMeshQuery::moveAlongSurface(dtPolyRef startRef, const float* start
 					neis[nneis++] = ref;
 				}
 			}
-			
+
 			if (!nneis)
 			{
 				// Wall edge, calc distance.
@@ -2082,7 +2082,7 @@ dtStatus dtNavMeshQuery::moveAlongSurface(dtPolyRef startRef, const float* start
 					// Skip if already visited.
 					if (neighbourNode->flags & DT_NODE_CLOSED)
 						continue;
-					
+
 					// Skip the link if it is too far from search constraint.
 					// TODO: Maybe should use getPortalPoints(), but this one is way faster.
 					const float* vj = &verts[j*3];
@@ -2091,7 +2091,7 @@ dtStatus dtNavMeshQuery::moveAlongSurface(dtPolyRef startRef, const float* start
 					float distSqr = dtDistancePtSegSqr2D(searchPos, vj, vi, tseg);
 					if (distSqr > searchRadSqr)
 						continue;
-					
+
 					// Mark as the node as visited and push to queue.
 					if (nstack < MAX_STACK)
 					{
@@ -2103,7 +2103,7 @@ dtStatus dtNavMeshQuery::moveAlongSurface(dtPolyRef startRef, const float* start
 			}
 		}
 	}
-	
+
 	int n = 0;
 	if (bestNode)
 	{
@@ -2118,7 +2118,7 @@ dtStatus dtNavMeshQuery::moveAlongSurface(dtPolyRef startRef, const float* start
 			node = next;
 		}
 		while (node);
-		
+
 		// Store result
 		node = prev;
 		do
@@ -2133,11 +2133,11 @@ dtStatus dtNavMeshQuery::moveAlongSurface(dtPolyRef startRef, const float* start
 		}
 		while (node);
 	}
-	
+
 	dtVcopy(resultPos, bestPos);
-	
+
 	*visitedCount = n;
-	
+
 	return status;
 }
 
@@ -2146,7 +2146,7 @@ dtStatus dtNavMeshQuery::getPortalPoints(dtPolyRef from, dtPolyRef to, float* le
 										 unsigned char& fromType, unsigned char& toType) const
 {
 	dtAssert(m_nav);
-	
+
 	const dtMeshTile* fromTile = 0;
 	const dtPoly* fromPoly = 0;
 	if (dtStatusFailed(m_nav->getTileAndPolyByRef(from, &fromTile, &fromPoly)))
@@ -2158,7 +2158,7 @@ dtStatus dtNavMeshQuery::getPortalPoints(dtPolyRef from, dtPolyRef to, float* le
 	if (dtStatusFailed(m_nav->getTileAndPolyByRef(to, &toTile, &toPoly)))
 		return DT_FAILURE | DT_INVALID_PARAM;
 	toType = toPoly->getType();
-		
+
 	return getPortalPoints(from, fromPoly, fromTile, to, toPoly, toTile, left, right);
 }
 
@@ -2179,7 +2179,7 @@ dtStatus dtNavMeshQuery::getPortalPoints(dtPolyRef from, const dtPoly* fromPoly,
 	}
 	if (!link)
 		return DT_FAILURE | DT_INVALID_PARAM;
-	
+
 	// Handle off-mesh connections.
 	if (fromPoly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
 	{
@@ -2196,7 +2196,7 @@ dtStatus dtNavMeshQuery::getPortalPoints(dtPolyRef from, const dtPoly* fromPoly,
 		}
 		return DT_FAILURE | DT_INVALID_PARAM;
 	}
-	
+
 	if (toPoly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
 	{
 		for (unsigned int i = toPoly->firstLink; i != DT_NULL_LINK; i = toTile->links[i].next)
@@ -2211,13 +2211,13 @@ dtStatus dtNavMeshQuery::getPortalPoints(dtPolyRef from, const dtPoly* fromPoly,
 		}
 		return DT_FAILURE | DT_INVALID_PARAM;
 	}
-	
+
 	// Find portal vertices.
 	const int v0 = fromPoly->verts[link->edge];
 	const int v1 = fromPoly->verts[(link->edge+1) % (int)fromPoly->vertCount];
 	dtVcopy(left, &fromTile->verts[v0*3]);
 	dtVcopy(right, &fromTile->verts[v1*3]);
-	
+
 	// If the link is at tile boundary, dtClamp the vertices to
 	// the link width.
 	if (link->side != 0xff)
@@ -2232,7 +2232,7 @@ dtStatus dtNavMeshQuery::getPortalPoints(dtPolyRef from, const dtPoly* fromPoly,
 			dtVlerp(right, &fromTile->verts[v0*3], &fromTile->verts[v1*3], tmax);
 		}
 	}
-	
+
 	return DT_SUCCESS;
 }
 
@@ -2268,16 +2268,16 @@ dtStatus dtNavMeshQuery::getEdgeMidPoint(dtPolyRef from, const dtPoly* fromPoly,
 ///
 /// This method is meant to be used for quick, short distance checks.
 ///
-/// If the path array is too small to hold the result, it will be filled as 
+/// If the path array is too small to hold the result, it will be filled as
 /// far as possible from the start postion toward the end position.
 ///
 /// <b>Using the Hit Parameter (t)</b>
-/// 
-/// If the hit parameter is a very high value (FLT_MAX), then the ray has hit 
-/// the end position. In this case the path represents a valid corridor to the 
+///
+/// If the hit parameter is a very high value (FLT_MAX), then the ray has hit
+/// the end position. In this case the path represents a valid corridor to the
 /// end position and the value of @p hitNormal is undefined.
 ///
-/// If the hit parameter is zero, then the start position is on the wall that 
+/// If the hit parameter is zero, then the start position is on the wall that
 /// was hit and the value of @p hitNormal is undefined.
 ///
 /// If 0 < t < 1.0 then the following applies:
@@ -2289,15 +2289,15 @@ dtStatus dtNavMeshQuery::getEdgeMidPoint(dtPolyRef from, const dtPoly* fromPoly,
 ///
 /// <b>Use Case Restriction</b>
 ///
-/// The raycast ignores the y-value of the end position. (2D check.) This 
+/// The raycast ignores the y-value of the end position. (2D check.) This
 /// places significant limits on how it can be used. For example:
 ///
-/// Consider a scene where there is a main floor with a second floor balcony 
-/// that hangs over the main floor. So the first floor mesh extends below the 
-/// balcony mesh. The start position is somewhere on the first floor. The end 
+/// Consider a scene where there is a main floor with a second floor balcony
+/// that hangs over the main floor. So the first floor mesh extends below the
+/// balcony mesh. The start position is somewhere on the first floor. The end
 /// position is on the balcony.
 ///
-/// The raycast will search toward the end position along the first floor mesh. 
+/// The raycast will search toward the end position along the first floor mesh.
 /// If it reaches the end position's xz-coordinates it will indicate FLT_MAX
 /// (no wall hit), meaning it reached the end position. This is one example of why
 /// this method is meant for short distance checks.
@@ -2311,7 +2311,7 @@ dtStatus dtNavMeshQuery::raycast(dtPolyRef startRef, const float* startPos, cons
 	hit.maxPath = maxPath;
 
 	dtStatus status = raycast(startRef, startPos, endPos, filter, 0, &hit);
-	
+
 	*t = hit.t;
 	if (hitNormal)
 		dtVcopy(hitNormal, hit.hitNormal);
@@ -2326,16 +2326,16 @@ dtStatus dtNavMeshQuery::raycast(dtPolyRef startRef, const float* startPos, cons
 ///
 /// This method is meant to be used for quick, short distance checks.
 ///
-/// If the path array is too small to hold the result, it will be filled as 
+/// If the path array is too small to hold the result, it will be filled as
 /// far as possible from the start postion toward the end position.
 ///
 /// <b>Using the Hit Parameter t of RaycastHit</b>
-/// 
-/// If the hit parameter is a very high value (FLT_MAX), then the ray has hit 
-/// the end position. In this case the path represents a valid corridor to the 
+///
+/// If the hit parameter is a very high value (FLT_MAX), then the ray has hit
+/// the end position. In this case the path represents a valid corridor to the
 /// end position and the value of @p hitNormal is undefined.
 ///
-/// If the hit parameter is zero, then the start position is on the wall that 
+/// If the hit parameter is zero, then the start position is on the wall that
 /// was hit and the value of @p hitNormal is undefined.
 ///
 /// If 0 < t < 1.0 then the following applies:
@@ -2347,15 +2347,15 @@ dtStatus dtNavMeshQuery::raycast(dtPolyRef startRef, const float* startPos, cons
 ///
 /// <b>Use Case Restriction</b>
 ///
-/// The raycast ignores the y-value of the end position. (2D check.) This 
+/// The raycast ignores the y-value of the end position. (2D check.) This
 /// places significant limits on how it can be used. For example:
 ///
-/// Consider a scene where there is a main floor with a second floor balcony 
-/// that hangs over the main floor. So the first floor mesh extends below the 
-/// balcony mesh. The start position is somewhere on the first floor. The end 
+/// Consider a scene where there is a main floor with a second floor balcony
+/// that hangs over the main floor. So the first floor mesh extends below the
+/// balcony mesh. The start position is somewhere on the first floor. The end
 /// position is on the balcony.
 ///
-/// The raycast will search toward the end position along the first floor mesh. 
+/// The raycast will search toward the end position along the first floor mesh.
 /// If it reaches the end position's xz-coordinates it will indicate FLT_MAX
 /// (no wall hit), meaning it reached the end position. This is one example of why
 /// this method is meant for short distance checks.
@@ -2365,7 +2365,7 @@ dtStatus dtNavMeshQuery::raycast(dtPolyRef startRef, const float* startPos, cons
 								 dtRaycastHit* hit, dtPolyRef prevRef) const
 {
 	dtAssert(m_nav);
-	
+
 	hit->t = 0;
 	hit->pathCount = 0;
 	hit->pathCost = 0;
@@ -2375,9 +2375,9 @@ dtStatus dtNavMeshQuery::raycast(dtPolyRef startRef, const float* startPos, cons
 		return DT_FAILURE | DT_INVALID_PARAM;
 	if (prevRef && !m_nav->isValidPolyRef(prevRef))
 		return DT_FAILURE | DT_INVALID_PARAM;
-	
+
 	float dir[3], curPos[3], lastPos[3];
-	float verts[DT_VERTS_PER_POLYGON*3+3];	
+	float verts[DT_VERTS_PER_POLYGON*3+3];
 	int n = 0;
 
 	dtVcopy(curPos, startPos);
@@ -2403,15 +2403,15 @@ dtStatus dtNavMeshQuery::raycast(dtPolyRef startRef, const float* startPos, cons
 	while (curRef)
 	{
 		// Cast ray against current polygon.
-		
+
 		// Collect vertices.
 		int nv = 0;
 		for (int i = 0; i < (int)poly->vertCount; ++i)
 		{
 			dtVcopy(&verts[nv*3], &tile->verts[poly->verts[i]*3]);
 			nv++;
 		}
-		
+
 		float tmin, tmax;
 		int segMin, segMax;
 		if (!dtIntersectSegmentPoly2D(startPos, endPos, verts, nv, tmin, tmax, segMin, segMax))
@@ -2423,7 +2423,7 @@ dtStatus dtNavMeshQuery::raycast(dtPolyRef startRef, const float* startPos, cons
 		// Keep track of furthest t so far.
 		if (tmax > hit->t)
 			hit->t = tmax;
-		
+
 		// Store visited polygons.
 		if (n < hit->maxPath)
 			hit->path[n++] = curRef;
@@ -2435,7 +2435,7 @@ dtStatus dtNavMeshQuery::raycast(dtPolyRef startRef, const float* startPos, cons
 		{
 			hit->t = FLT_MAX;
 			hit->pathCount = n;
-			
+
 			// add the cost
 			if (options & DT_RAYCAST_USE_COSTS)
 				hit->pathCost += filter->getCost(curPos, endPos, prevRef, prevTile, prevPoly, curRef, tile, poly, curRef, tile, poly);
@@ -2444,50 +2444,50 @@ dtStatus dtNavMeshQuery::raycast(dtPolyRef startRef, const float* startPos, cons
 
 		// Follow neighbours.
 		nextRef = 0;
-		
+
 		for (unsigned int i = poly->firstLink; i != DT_NULL_LINK; i = tile->links[i].next)
 		{
 			const dtLink* link = &tile->links[i];
-			
+
 			// Find link which contains this edge.
 			if ((int)link->edge != segMax)
 				continue;
-			
+
 			// Get pointer to the next polygon.
 			nextTile = 0;
 			nextPoly = 0;
 			m_nav->getTileAndPolyByRefUnsafe(link->ref, &nextTile, &nextPoly);
-			
+
 			// Skip off-mesh connections.
 			if (nextPoly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
 				continue;
-			
+
 			// Skip links based on filter.
 			if (!filter->passFilter(link->ref, nextTile, nextPoly))
 				continue;
-			
+
 			// If the link is internal, just return the ref.
 			if (link->side == 0xff)
 			{
 				nextRef = link->ref;
 				break;
 			}
-			
+
 			// If the link is at tile boundary,
-			
+
 			// Check if the link spans the whole edge, and accept.
 			if (link->bmin == 0 && link->bmax == 255)
 			{
 				nextRef = link->ref;
 				break;
 			}
-			
+
 			// Check for partial edge links.
 			const int v0 = poly->verts[link->edge];
 			const int v1 = poly->verts[(link->edge+1) % poly->vertCount];
 			const float* left = &tile->verts[v0*3];
 			const float* right = &tile->verts[v1*3];
-			
+
 			// Check that the intersection lies inside the link portal.
 			if (link->side == 0 || link->side == 4)
 			{
@@ -2496,7 +2496,7 @@ dtStatus dtNavMeshQuery::raycast(dtPolyRef startRef, const float* startPos, cons
 				float lmin = left[2] + (right[2] - left[2])*(link->bmin*s);
 				float lmax = left[2] + (right[2] - left[2])*(link->bmax*s);
 				if (lmin > lmax) dtSwap(lmin, lmax);
-				
+
 				// Find Z intersection.
 				float z = startPos[2] + (endPos[2]-startPos[2])*tmax;
 				if (z >= lmin && z <= lmax)
@@ -2512,7 +2512,7 @@ dtStatus dtNavMeshQuery::raycast(dtPolyRef startRef, const float* startPos, cons
 				float lmin = left[0] + (right[0] - left[0])*(link->bmin*s);
 				float lmax = left[0] + (right[0] - left[0])*(link->bmax*s);
 				if (lmin > lmax) dtSwap(lmin, lmax);
-				
+
 				// Find X intersection.
 				float x = startPos[0] + (endPos[0]-startPos[0])*tmax;
 				if (x >= lmin && x <= lmax)
@@ -2522,7 +2522,7 @@ dtStatus dtNavMeshQuery::raycast(dtPolyRef startRef, const float* startPos, cons
 				}
 			}
 		}
-		
+
 		// add the cost
 		if (options & DT_RAYCAST_USE_COSTS)
 		{
@@ -2544,7 +2544,7 @@ dtStatus dtNavMeshQuery::raycast(dtPolyRef startRef, const float* startPos, cons
 		if (!nextRef)
 		{
 			// No neighbour, we hit a wall.
-			
+
 			// Calculate hit normal.
 			const int a = segMax;
 			const int b = segMax+1 < nv ? segMax+1 : 0;
@@ -2556,7 +2556,7 @@ dtStatus dtNavMeshQuery::raycast(dtPolyRef startRef, const float* startPos, cons
 			hit->hitNormal[1] = 0;
 			hit->hitNormal[2] = -dx;
 			dtVnormalize(hit->hitNormal);
-			
+
 			hit->pathCount = n;
 			return status;
 		}
@@ -2569,9 +2569,9 @@ dtStatus dtNavMeshQuery::raycast(dtPolyRef startRef, const float* startPos, cons
 		prevPoly = poly;
 		poly = nextPoly;
 	}
-	
+
 	hit->pathCount = n;
-	
+
 	return status;
 }
 
@@ -2581,29 +2581,29 @@ dtStatus dtNavMeshQuery::raycast(dtPolyRef startRef, const float* startPos, cons
 ///
 /// The order of the result set is from least to highest cost to reach the polygon.
 ///
-/// A common use case for this method is to perform Dijkstra searches. 
+/// A common use case for this method is to perform Dijkstra searches.
 /// Candidate polygons are found by searching the graph beginning at the start polygon.
 ///
-/// If a polygon is not found via the graph search, even if it intersects the 
+/// If a polygon is not found via the graph search, even if it intersects the
 /// search circle, it will not be included in the result set. For example:
 ///
 /// polyA is the start polygon.
 /// polyB shares an edge with polyA. (Is adjacent.)
 /// polyC shares an edge with polyB, but not with polyA
-/// Even if the search circle overlaps polyC, it will not be included in the 
+/// Even if the search circle overlaps polyC, it will not be included in the
 /// result set unless polyB is also in the set.
-/// 
-/// The value of the center point is used as the start position for cost 
-/// calculations. It is not projected onto the surface of the mesh, so its 
+///
+/// The value of the center point is used as the start position for cost
+/// calculations. It is not projected onto the surface of the mesh, so its
 /// y-value will effect the costs.
 ///
-/// Intersection tests occur in 2D. All polygons and the search circle are 
-/// projected onto the xz-plane. So the y-value of the center point does not 
+/// Intersection tests occur in 2D. All polygons and the search circle are
+/// projected onto the xz-plane. So the y-value of the center point does not
 /// effect intersection tests.
 ///
-/// If the result arrays are to small to hold the entire result set, they will be 
+/// If the result arrays are to small to hold the entire result set, they will be
 /// filled to capacity.
-/// 
+///
 dtStatus dtNavMeshQuery::findPolysAroundCircle(dtPolyRef startRef, const float* centerPos, const float radius,
 											   const dtQueryFilter* filter,
 											   dtPolyRef* resultRef, dtPolyRef* resultParent, float* resultCost,
@@ -2614,14 +2614,14 @@ dtStatus dtNavMeshQuery::findPolysAroundCircle(dtPolyRef startRef, const float*
 	dtAssert(m_openList);
 
 	*resultCount = 0;
-	
+
 	// Validate input
 	if (!startRef || !m_nav->isValidPolyRef(startRef))
 		return DT_FAILURE | DT_INVALID_PARAM;
-	
+
 	m_nodePool->clear();
 	m_openList->clear();
-	
+
 	dtNode* startNode = m_nodePool->getNode(startRef);
 	dtVcopy(startNode->pos, centerPos);
 	startNode->pidx = 0;
@@ -2630,9 +2630,9 @@ dtStatus dtNavMeshQuery::findPolysAroundCircle(dtPolyRef startRef, const float*
 	startNode->id = startRef;
 	startNode->flags = DT_NODE_OPEN;
 	m_openList->push(startNode);
-	
+
 	dtStatus status = DT_SUCCESS;
-	
+
 	int n = 0;
 	if (n < maxResult)
 	{
@@ -2648,22 +2648,22 @@ dtStatus dtNavMeshQuery::findPolysAroundCircle(dtPolyRef startRef, const float*
 	{
 		status |= DT_BUFFER_TOO_SMALL;
 	}
-	
+
 	const float radiusSqr = dtSqr(radius);
-	
+
 	while (!m_openList->empty())
 	{
 		dtNode* bestNode = m_openList->pop();
 		bestNode->flags &= ~DT_NODE_OPEN;
 		bestNode->flags |= DT_NODE_CLOSED;
-		
+
 		// Get poly and tile.
 		// The API input has been cheked already, skip checking internal data.
 		const dtPolyRef bestRef = bestNode->id;
 		const dtMeshTile* bestTile = 0;
 		const dtPoly* bestPoly = 0;
 		m_nav->getTileAndPolyByRefUnsafe(bestRef, &bestTile, &bestPoly);
-		
+
 		// Get parent poly and tile.
 		dtPolyRef parentRef = 0;
 		const dtMeshTile* parentTile = 0;
@@ -2672,60 +2672,60 @@ dtStatus dtNavMeshQuery::findPolysAroundCircle(dtPolyRef startRef, const float*
 			parentRef = m_nodePool->getNodeAtIdx(bestNode->pidx)->id;
 		if (parentRef)
 			m_nav->getTileAndPolyByRefUnsafe(parentRef, &parentTile, &parentPoly);
-		
+
 		for (unsigned int i = bestPoly->firstLink; i != DT_NULL_LINK; i = bestTile->links[i].next)
 		{
 			const dtLink* link = &bestTile->links[i];
 			dtPolyRef neighbourRef = link->ref;
 			// Skip invalid neighbours and do not follow back to parent.
 			if (!neighbourRef || neighbourRef == parentRef)
 				continue;
-			
+
 			// Expand to neighbour
 			const dtMeshTile* neighbourTile = 0;
 			const dtPoly* neighbourPoly = 0;
 			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);
-		
+
 			// Do not advance if the polygon is excluded by the filter.
 			if (!filter->passFilter(neighbourRef, neighbourTile, neighbourPoly))
 				continue;
-			
+
 			// Find edge and calc distance to the edge.
 			float va[3], vb[3];
 			if (!getPortalPoints(bestRef, bestPoly, bestTile, neighbourRef, neighbourPoly, neighbourTile, va, vb))
 				continue;
-			
+
 			// If the circle is not touching the next polygon, skip it.
 			float tseg;
 			float distSqr = dtDistancePtSegSqr2D(centerPos, va, vb, tseg);
 			if (distSqr > radiusSqr)
 				continue;
-			
+
 			dtNode* neighbourNode = m_nodePool->getNode(neighbourRef);
 			if (!neighbourNode)
 			{
 				status |= DT_OUT_OF_NODES;
 				continue;
 			}
-				
+
 			if (neighbourNode->flags & DT_NODE_CLOSED)
 				continue;
-			
+
 			// Cost
 			if (neighbourNode->flags == 0)
 				dtVlerp(neighbourNode->pos, va, vb, 0.5f);
-			
+
 			const float total = bestNode->total + dtVdist(bestNode->pos, neighbourNode->pos);
-			
+
 			// The node is already in open list and the new result is worse, skip.
 			if ((neighbourNode->flags & DT_NODE_OPEN) && total >= neighbourNode->total)
 				continue;
-			
+
 			neighbourNode->id = neighbourRef;
 			neighbourNode->flags = (neighbourNode->flags & ~DT_NODE_CLOSED);
 			neighbourNode->pidx = m_nodePool->getNodeIdx(bestNode);
 			neighbourNode->total = total;
-			
+
 			if (neighbourNode->flags & DT_NODE_OPEN)
 			{
 				m_openList->modify(neighbourNode);
@@ -2751,32 +2751,32 @@ dtStatus dtNavMeshQuery::findPolysAroundCircle(dtPolyRef startRef, const float*
 			}
 		}
 	}
-	
+
 	*resultCount = n;
-	
+
 	return status;
 }
 
 /// @par
 ///
 /// The order of the result set is from least to highest cost.
-/// 
+///
 /// At least one result array must be provided.
 ///
-/// A common use case for this method is to perform Dijkstra searches. 
-/// Candidate polygons are found by searching the graph beginning at the start 
+/// A common use case for this method is to perform Dijkstra searches.
+/// Candidate polygons are found by searching the graph beginning at the start
 /// polygon.
-/// 
+///
 /// The same intersection test restrictions that apply to findPolysAroundCircle()
 /// method apply to this method.
-/// 
-/// The 3D centroid of the search polygon is used as the start position for cost 
+///
+/// The 3D centroid of the search polygon is used as the start position for cost
 /// calculations.
-/// 
-/// Intersection tests occur in 2D. All polygons are projected onto the 
+///
+/// Intersection tests occur in 2D. All polygons are projected onto the
 /// xz-plane. So the y-values of the vertices do not effect intersection tests.
-/// 
-/// If the result arrays are is too small to hold the entire result set, they will 
+///
+/// If the result arrays are is too small to hold the entire result set, they will
 /// be filled to capacity.
 ///
 dtStatus dtNavMeshQuery::findPolysAroundShape(dtPolyRef startRef, const float* verts, const int nverts,
@@ -2787,16 +2787,16 @@ dtStatus dtNavMeshQuery::findPolysAroundShape(dtPolyRef startRef, const float* v
 	dtAssert(m_nav);
 	dtAssert(m_nodePool);
 	dtAssert(m_openList);
-	
+
 	*resultCount = 0;
-	
+
 	// Validate input
 	if (!startRef || !m_nav->isValidPolyRef(startRef))
 		return DT_FAILURE | DT_INVALID_PARAM;
-	
+
 	m_nodePool->clear();
 	m_openList->clear();
-	
+
 	float centerPos[3] = {0,0,0};
 	for (int i = 0; i < nverts; ++i)
 		dtVadd(centerPos,centerPos,&verts[i*3]);
@@ -2810,7 +2810,7 @@ dtStatus dtNavMeshQuery::findPolysAroundShape(dtPolyRef startRef, const float* v
 	startNode->id = startRef;
 	startNode->flags = DT_NODE_OPEN;
 	m_openList->push(startNode);
-	
+
 	dtStatus status = DT_SUCCESS;
 
 	int n = 0;
@@ -2828,20 +2828,20 @@ dtStatus dtNavMeshQuery::findPolysAroundShape(dtPolyRef startRef, const float* v
 	{
 		status |= DT_BUFFER_TOO_SMALL;
 	}
-	
+
 	while (!m_openList->empty())
 	{
 		dtNode* bestNode = m_openList->pop();
 		bestNode->flags &= ~DT_NODE_OPEN;
 		bestNode->flags |= DT_NODE_CLOSED;
-		
+
 		// Get poly and tile.
 		// The API input has been cheked already, skip checking internal data.
 		const dtPolyRef bestRef = bestNode->id;
 		const dtMeshTile* bestTile = 0;
 		const dtPoly* bestPoly = 0;
 		m_nav->getTileAndPolyByRefUnsafe(bestRef, &bestTile, &bestPoly);
-		
+
 		// Get parent poly and tile.
 		dtPolyRef parentRef = 0;
 		const dtMeshTile* parentTile = 0;
@@ -2850,62 +2850,62 @@ dtStatus dtNavMeshQuery::findPolysAroundShape(dtPolyRef startRef, const float* v
 			parentRef = m_nodePool->getNodeAtIdx(bestNode->pidx)->id;
 		if (parentRef)
 			m_nav->getTileAndPolyByRefUnsafe(parentRef, &parentTile, &parentPoly);
-		
+
 		for (unsigned int i = bestPoly->firstLink; i != DT_NULL_LINK; i = bestTile->links[i].next)
 		{
 			const dtLink* link = &bestTile->links[i];
 			dtPolyRef neighbourRef = link->ref;
 			// Skip invalid neighbours and do not follow back to parent.
 			if (!neighbourRef || neighbourRef == parentRef)
 				continue;
-			
+
 			// Expand to neighbour
 			const dtMeshTile* neighbourTile = 0;
 			const dtPoly* neighbourPoly = 0;
 			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);
-			
+
 			// Do not advance if the polygon is excluded by the filter.
 			if (!filter->passFilter(neighbourRef, neighbourTile, neighbourPoly))
 				continue;
-			
+
 			// Find edge and calc distance to the edge.
 			float va[3], vb[3];
 			if (!getPortalPoints(bestRef, bestPoly, bestTile, neighbourRef, neighbourPoly, neighbourTile, va, vb))
 				continue;
-			
+
 			// If the poly is not touching the edge to the next polygon, skip the connection it.
 			float tmin, tmax;
 			int segMin, segMax;
 			if (!dtIntersectSegmentPoly2D(va, vb, verts, nverts, tmin, tmax, segMin, segMax))
 				continue;
 			if (tmin > 1.0f || tmax < 0.0f)
 				continue;
-			
+
 			dtNode* neighbourNode = m_nodePool->getNode(neighbourRef);
 			if (!neighbourNode)
 			{
 				status |= DT_OUT_OF_NODES;
 				continue;
 			}
-			
+
 			if (neighbourNode->flags & DT_NODE_CLOSED)
 				continue;
-			
+
 			// Cost
 			if (neighbourNode->flags == 0)
 				dtVlerp(neighbourNode->pos, va, vb, 0.5f);
-			
+
 			const float total = bestNode->total + dtVdist(bestNode->pos, neighbourNode->pos);
-			
+
 			// The node is already in open list and the new result is worse, skip.
 			if ((neighbourNode->flags & DT_NODE_OPEN) && total >= neighbourNode->total)
 				continue;
-			
+
 			neighbourNode->id = neighbourRef;
 			neighbourNode->flags = (neighbourNode->flags & ~DT_NODE_CLOSED);
 			neighbourNode->pidx = m_nodePool->getNodeIdx(bestNode);
 			neighbourNode->total = total;
-			
+
 			if (neighbourNode->flags & DT_NODE_OPEN)
 			{
 				m_openList->modify(neighbourNode);
@@ -2931,67 +2931,67 @@ dtStatus dtNavMeshQuery::findPolysAroundShape(dtPolyRef startRef, const float* v
 			}
 		}
 	}
-	
+
 	*resultCount = n;
-	
+
 	return status;
 }
 
 /// @par
 ///
-/// This method is optimized for a small search radius and small number of result 
+/// This method is optimized for a small search radius and small number of result
 /// polygons.
 ///
-/// Candidate polygons are found by searching the navigation graph beginning at 
+/// Candidate polygons are found by searching the navigation graph beginning at
 /// the start polygon.
 ///
-/// The same intersection test restrictions that apply to the findPolysAroundCircle 
+/// The same intersection test restrictions that apply to the findPolysAroundCircle
 /// mehtod applies to this method.
 ///
-/// The value of the center point is used as the start point for cost calculations. 
-/// It is not projected onto the surface of the mesh, so its y-value will effect 
+/// The value of the center point is used as the start point for cost calculations.
+/// It is not projected onto the surface of the mesh, so its y-value will effect
 /// the costs.
-/// 
-/// Intersection tests occur in 2D. All polygons and the search circle are 
-/// projected onto the xz-plane. So the y-value of the center point does not 
+///
+/// Intersection tests occur in 2D. All polygons and the search circle are
+/// projected onto the xz-plane. So the y-value of the center point does not
 /// effect intersection tests.
-/// 
-/// If the result arrays are is too small to hold the entire result set, they will 
+///
+/// If the result arrays are is too small to hold the entire result set, they will
 /// be filled to capacity.
-/// 
+///
 dtStatus dtNavMeshQuery::findLocalNeighbourhood(dtPolyRef startRef, const float* centerPos, const float radius,
 												const dtQueryFilter* filter,
 												dtPolyRef* resultRef, dtPolyRef* resultParent,
 												int* resultCount, const int maxResult) const
 {
 	dtAssert(m_nav);
 	dtAssert(m_tinyNodePool);
-	
+
 	*resultCount = 0;
 
 	// Validate input
 	if (!startRef || !m_nav->isValidPolyRef(startRef))
 		return DT_FAILURE | DT_INVALID_PARAM;
-	
+
 	static const int MAX_STACK = 48;
 	dtNode* stack[MAX_STACK];
 	int nstack = 0;
-	
+
 	m_tinyNodePool->clear();
-	
+
 	dtNode* startNode = m_tinyNodePool->getNode(startRef);
 	startNode->pidx = 0;
 	startNode->id = startRef;
 	startNode->flags = DT_NODE_CLOSED;
 	stack[nstack++] = startNode;
-	
+
 	const float radiusSqr = dtSqr(radius);
-	
+
 	float pa[DT_VERTS_PER_POLYGON*3];
 	float pb[DT_VERTS_PER_POLYGON*3];
-	
+
 	dtStatus status = DT_SUCCESS;
-	
+
 	int n = 0;
 	if (n < maxResult)
 	{
@@ -3004,79 +3004,79 @@ dtStatus dtNavMeshQuery::findLocalNeighbourhood(dtPolyRef startRef, const float*
 	{
 		status |= DT_BUFFER_TOO_SMALL;
 	}
-	
+
 	while (nstack)
 	{
 		// Pop front.
 		dtNode* curNode = stack[0];
 		for (int i = 0; i < nstack-1; ++i)
 			stack[i] = stack[i+1];
 		nstack--;
-		
+
 		// Get poly and tile.
 		// The API input has been cheked already, skip checking internal data.
 		const dtPolyRef curRef = curNode->id;
 		const dtMeshTile* curTile = 0;
 		const dtPoly* curPoly = 0;
 		m_nav->getTileAndPolyByRefUnsafe(curRef, &curTile, &curPoly);
-		
+
 		for (unsigned int i = curPoly->firstLink; i != DT_NULL_LINK; i = curTile->links[i].next)
 		{
 			const dtLink* link = &curTile->links[i];
 			dtPolyRef neighbourRef = link->ref;
 			// Skip invalid neighbours.
 			if (!neighbourRef)
 				continue;
-			
+
 			// Skip if cannot alloca more nodes.
 			dtNode* neighbourNode = m_tinyNodePool->getNode(neighbourRef);
 			if (!neighbourNode)
 				continue;
 			// Skip visited.
 			if (neighbourNode->flags & DT_NODE_CLOSED)
 				continue;
-			
+
 			// Expand to neighbour
 			const dtMeshTile* neighbourTile = 0;
 			const dtPoly* neighbourPoly = 0;
 			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);
-			
+
 			// Skip off-mesh connections.
 			if (neighbourPoly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
 				continue;
-			
+
 			// Do not advance if the polygon is excluded by the filter.
 			if (!filter->passFilter(neighbourRef, neighbourTile, neighbourPoly))
 				continue;
-			
+
 			// Find edge and calc distance to the edge.
 			float va[3], vb[3];
 			if (!getPortalPoints(curRef, curPoly, curTile, neighbourRef, neighbourPoly, neighbourTile, va, vb))
 				continue;
-			
+
 			// If the circle is not touching the next polygon, skip it.
 			float tseg;
 			float distSqr = dtDistancePtSegSqr2D(centerPos, va, vb, tseg);
 			if (distSqr > radiusSqr)
 				continue;
-			
+
 			// Mark node visited, this is done before the overlap test so that
 			// we will not visit the poly again if the test fails.
 			neighbourNode->flags |= DT_NODE_CLOSED;
 			neighbourNode->pidx = m_tinyNodePool->getNodeIdx(curNode);
-			
+
 			// Check that the polygon does not collide with existing polygons.
-			
+
 			// Collect vertices of the neighbour poly.
 			const int npa = neighbourPoly->vertCount;
 			for (int k = 0; k < npa; ++k)
 				dtVcopy(&pa[k*3], &neighbourTile->verts[neighbourPoly->verts[k]*3]);
-			
+
 			bool overlap = false;
 			for (int j = 0; j < n; ++j)
 			{
 				dtPolyRef pastRef = resultRef[j];
-				
+
 				// Connected polys do not overlap.
 				bool connected = false;
 				for (unsigned int k = curPoly->firstLink; k != DT_NULL_LINK; k = curTile->links[k].next)
@@ -3089,17 +3089,17 @@ dtStatus dtNavMeshQuery::findLocalNeighbourhood(dtPolyRef startRef, const float*
 				}
 				if (connected)
 					continue;
-				
+
 				// Potentially overlapping.
 				const dtMeshTile* pastTile = 0;
 				const dtPoly* pastPoly = 0;
 				m_nav->getTileAndPolyByRefUnsafe(pastRef, &pastTile, &pastPoly);
-				
+
 				// Get vertices and test overlap
 				const int npb = pastPoly->vertCount;
 				for (int k = 0; k < npb; ++k)
 					dtVcopy(&pb[k*3], &pastTile->verts[pastPoly->verts[k]*3]);
-				
+
 				if (dtOverlapPolyPoly2D(pa,npa, pb,npb))
 				{
 					overlap = true;
@@ -3108,7 +3108,7 @@ dtStatus dtNavMeshQuery::findLocalNeighbourhood(dtPolyRef startRef, const float*
 			}
 			if (overlap)
 				continue;
-			
+
 			// This poly is fine, store and advance to the poly.
 			if (n < maxResult)
 			{
@@ -3121,16 +3121,16 @@ dtStatus dtNavMeshQuery::findLocalNeighbourhood(dtPolyRef startRef, const float*
 			{
 				status |= DT_BUFFER_TOO_SMALL;
 			}
-			
+
 			if (nstack < MAX_STACK)
 			{
 				stack[nstack++] = neighbourNode;
 			}
 		}
 	}
-	
+
 	*resultCount = n;
-	
+
 	return status;
 }
 
@@ -3165,37 +3165,37 @@ static void insertInterval(dtSegInterval* ints, int& nints, const int maxInts,
 
 /// @par
 ///
-/// If the @p segmentRefs parameter is provided, then all polygon segments will be returned. 
+/// If the @p segmentRefs parameter is provided, then all polygon segments will be returned.
 /// Otherwise only the wall segments are returned.
-/// 
-/// A segment that is normally a portal will be included in the result set as a 
+///
+/// A segment that is normally a portal will be included in the result set as a
 /// wall if the @p filter results in the neighbor polygon becoomming impassable.
-/// 
-/// The @p segmentVerts and @p segmentRefs buffers should normally be sized for the 
+///
+/// The @p segmentVerts and @p segmentRefs buffers should normally be sized for the
 /// maximum segments per polygon of the source navigation mesh.
-/// 
+///
 dtStatus dtNavMeshQuery::getPolyWallSegments(dtPolyRef ref, const dtQueryFilter* filter,
 											 float* segmentVerts, dtPolyRef* segmentRefs, int* segmentCount,
 											 const int maxSegments) const
 {
 	dtAssert(m_nav);
-	
+
 	*segmentCount = 0;
-	
+
 	const dtMeshTile* tile = 0;
 	const dtPoly* poly = 0;
 	if (dtStatusFailed(m_nav->getTileAndPolyByRef(ref, &tile, &poly)))
 		return DT_FAILURE | DT_INVALID_PARAM;
-	
+
 	int n = 0;
 	static const int MAX_INTERVAL = 16;
 	dtSegInterval ints[MAX_INTERVAL];
 	int nints;
-	
+
 	const bool storePortals = segmentRefs != 0;
-	
+
 	dtStatus status = DT_SUCCESS;
-	
+
 	for (int i = 0, j = (int)poly->vertCount-1; i < (int)poly->vertCount; j = i++)
 	{
 		// Skip non-solid edges.
@@ -3236,7 +3236,7 @@ dtStatus dtNavMeshQuery::getPolyWallSegments(dtPolyRef ref, const dtQueryFilter*
 			// If the edge leads to another polygon and portals are not stored, skip.
 			if (neiRef != 0 && !storePortals)
 				continue;
-			
+
 			if (n < maxSegments)
 			{
 				const float* vj = &tile->verts[poly->verts[j]*3];
@@ -3252,14 +3252,14 @@ dtStatus dtNavMeshQuery::getPolyWallSegments(dtPolyRef ref, const dtQueryFilter*
 			{
 				status |= DT_BUFFER_TOO_SMALL;
 			}
-			
+
 			continue;
 		}
-		
+
 		// Add sentinels
 		insertInterval(ints, nints, MAX_INTERVAL, -1, 0, 0);
 		insertInterval(ints, nints, MAX_INTERVAL, 255, 256, 0);
-		
+
 		// Store segments.
 		const float* vj = &tile->verts[poly->verts[j]*3];
 		const float* vi = &tile->verts[poly->verts[i]*3];
@@ -3268,8 +3268,8 @@ dtStatus dtNavMeshQuery::getPolyWallSegments(dtPolyRef ref, const dtQueryFilter*
 			// Portal segment.
 			if (storePortals && ints[k].ref)
 			{
-				const float tmin = ints[k].tmin/255.0f; 
-				const float tmax = ints[k].tmax/255.0f; 
+				const float tmin = ints[k].tmin/255.0f;
+				const float tmax = ints[k].tmax/255.0f;
 				if (n < maxSegments)
 				{
 					float* seg = &segmentVerts[n*6];
@@ -3290,8 +3290,8 @@ dtStatus dtNavMeshQuery::getPolyWallSegments(dtPolyRef ref, const dtQueryFilter*
 			const int imax = ints[k].tmin;
 			if (imin != imax)
 			{
-				const float tmin = imin/255.0f; 
-				const float tmax = imax/255.0f; 
+				const float tmin = imin/255.0f;
+				const float tmax = imax/255.0f;
 				if (n < maxSegments)
 				{
 					float* seg = &segmentVerts[n*6];
@@ -3308,17 +3308,17 @@ dtStatus dtNavMeshQuery::getPolyWallSegments(dtPolyRef ref, const dtQueryFilter*
 			}
 		}
 	}
-	
+
 	*segmentCount = n;
-	
+
 	return status;
 }
 
 /// @par
 ///
 /// @p hitPos is not adjusted using the height detail data.
 ///
-/// @p hitDist will equal the search radius if there is no wall within the 
+/// @p hitDist will equal the search radius if there is no wall within the
 /// radius. In this case the values of @p hitPos and @p hitNormal are
 /// undefined.
 ///
@@ -3331,14 +3331,14 @@ dtStatus dtNavMeshQuery::findDistanceToWall(dtPolyRef startRef, const float* cen
 	dtAssert(m_nav);
 	dtAssert(m_nodePool);
 	dtAssert(m_openList);
-	
+
 	// Validate input
 	if (!startRef || !m_nav->isValidPolyRef(startRef))
 		return DT_FAILURE | DT_INVALID_PARAM;
-	
+
 	m_nodePool->clear();
 	m_openList->clear();
-	
+
 	dtNode* startNode = m_nodePool->getNode(startRef);
 	dtVcopy(startNode->pos, centerPos);
 	startNode->pidx = 0;
@@ -3347,24 +3347,24 @@ dtStatus dtNavMeshQuery::findDistanceToWall(dtPolyRef startRef, const float* cen
 	startNode->id = startRef;
 	startNode->flags = DT_NODE_OPEN;
 	m_openList->push(startNode);
-	
+
 	float radiusSqr = dtSqr(maxRadius);
-	
+
 	dtStatus status = DT_SUCCESS;
-	
+
 	while (!m_openList->empty())
 	{
 		dtNode* bestNode = m_openList->pop();
 		bestNode->flags &= ~DT_NODE_OPEN;
 		bestNode->flags |= DT_NODE_CLOSED;
-		
+
 		// Get poly and tile.
 		// The API input has been cheked already, skip checking internal data.
 		const dtPolyRef bestRef = bestNode->id;
 		const dtMeshTile* bestTile = 0;
 		const dtPoly* bestPoly = 0;
 		m_nav->getTileAndPolyByRefUnsafe(bestRef, &bestTile, &bestPoly);
-		
+
 		// Get parent poly and tile.
 		dtPolyRef parentRef = 0;
 		const dtMeshTile* parentTile = 0;
@@ -3373,7 +3373,7 @@ dtStatus dtNavMeshQuery::findDistanceToWall(dtPolyRef startRef, const float* cen
 			parentRef = m_nodePool->getNodeAtIdx(bestNode->pidx)->id;
 		if (parentRef)
 			m_nav->getTileAndPolyByRefUnsafe(parentRef, &parentTile, &parentPoly);
-		
+
 		// Hit test walls.
 		for (int i = 0, j = (int)bestPoly->vertCount-1; i < (int)bestPoly->vertCount; j = i++)
 		{
@@ -3408,52 +3408,52 @@ dtStatus dtNavMeshQuery::findDistanceToWall(dtPolyRef startRef, const float* cen
 				if (filter->passFilter(ref, bestTile, &bestTile->polys[idx]))
 					continue;
 			}
-			
+
 			// Calc distance to the edge.
 			const float* vj = &bestTile->verts[bestPoly->verts[j]*3];
 			const float* vi = &bestTile->verts[bestPoly->verts[i]*3];
 			float tseg;
 			float distSqr = dtDistancePtSegSqr2D(centerPos, vj, vi, tseg);
-			
+
 			// Edge is too far, skip.
 			if (distSqr > radiusSqr)
 				continue;
-			
+
 			// Hit wall, update radius.
 			radiusSqr = distSqr;
 			// Calculate hit pos.
 			hitPos[0] = vj[0] + (vi[0] - vj[0])*tseg;
 			hitPos[1] = vj[1] + (vi[1] - vj[1])*tseg;
 			hitPos[2] = vj[2] + (vi[2] - vj[2])*tseg;
 		}
-		
+
 		for (unsigned int i = bestPoly->firstLink; i != DT_NULL_LINK; i = bestTile->links[i].next)
 		{
 			const dtLink* link = &bestTile->links[i];
 			dtPolyRef neighbourRef = link->ref;
 			// Skip invalid neighbours and do not follow back to parent.
 			if (!neighbourRef || neighbourRef == parentRef)
 				continue;
-			
+
 			// Expand to neighbour.
 			const dtMeshTile* neighbourTile = 0;
 			const dtPoly* neighbourPoly = 0;
 			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);
-			
+
 			// Skip off-mesh connections.
 			if (neighbourPoly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
 				continue;
-			
+
 			// Calc distance to the edge.
 			const float* va = &bestTile->verts[bestPoly->verts[link->edge]*3];
 			const float* vb = &bestTile->verts[bestPoly->verts[(link->edge+1) % bestPoly->vertCount]*3];
 			float tseg;
 			float distSqr = dtDistancePtSegSqr2D(centerPos, va, vb, tseg);
-			
+
 			// If the circle is not touching the next polygon, skip it.
 			if (distSqr > radiusSqr)
 				continue;
-			
+
 			if (!filter->passFilter(neighbourRef, neighbourTile, neighbourPoly))
 				continue;
 
@@ -3463,28 +3463,28 @@ dtStatus dtNavMeshQuery::findDistanceToWall(dtPolyRef startRef, const float* cen
 				status |= DT_OUT_OF_NODES;
 				continue;
 			}
-			
+
 			if (neighbourNode->flags & DT_NODE_CLOSED)
 				continue;
-			
+
 			// Cost
 			if (neighbourNode->flags == 0)
 			{
 				getEdgeMidPoint(bestRef, bestPoly, bestTile,
 								neighbourRef, neighbourPoly, neighbourTile, neighbourNode->pos);
 			}
-			
+
 			const float total = bestNode->total + dtVdist(bestNode->pos, neighbourNode->pos);
-			
+
 			// The node is already in open list and the new result is worse, skip.
 			if ((neighbourNode->flags & DT_NODE_OPEN) && total >= neighbourNode->total)
 				continue;
-			
+
 			neighbourNode->id = neighbourRef;
 			neighbourNode->flags = (neighbourNode->flags & ~DT_NODE_CLOSED);
 			neighbourNode->pidx = m_nodePool->getNodeIdx(bestNode);
 			neighbourNode->total = total;
-				
+
 			if (neighbourNode->flags & DT_NODE_OPEN)
 			{
 				m_openList->modify(neighbourNode);
@@ -3496,13 +3496,13 @@ dtStatus dtNavMeshQuery::findDistanceToWall(dtPolyRef startRef, const float* cen
 			}
 		}
 	}
-	
+
 	// Calc hit normal.
 	dtVsub(hitNormal, centerPos, hitPos);
 	dtVnormalize(hitNormal);
-	
+
 	*hitDist = dtMathSqrtf(radiusSqr);
-	
+
 	return status;
 }
 
@@ -3522,21 +3522,21 @@ bool dtNavMeshQuery::isValidPolyRef(dtPolyRef ref, const dtQueryFilter* filter)
 
 /// @par
 ///
-/// The closed list is the list of polygons that were fully evaluated during 
+/// The closed list is the list of polygons that were fully evaluated during
 /// the last navigation graph search. (A* or Dijkstra)
-/// 
+///
 bool dtNavMeshQuery::isInClosedList(dtPolyRef ref) const
 {
 	if (!m_nodePool) return false;
-	
+
 	dtNode* nodes[DT_MAX_STATES_PER_NODE];
 	int n= m_nodePool->findNodes(ref, nodes, DT_MAX_STATES_PER_NODE);
 
 	for (int i=0; i<n; i++)
 	{
 		if (nodes[i]->flags & DT_NODE_CLOSED)
 			return true;
-	}		
+	}
 
 	return false;
 }