@@ -28,7 +28,8 @@ along with this program.  If not, see http://www.gnu.org/licenses/
 #include "../common/timer.h"
 #include "../common/utils.h"
 
-#include <string.h>
+#include <cstring>
+
 #include "alliance.h"
 #include "utils/blueutils.h"
 #include "party.h"
@@ -40,13 +41,17 @@ along with this program.  If not, see http://www.gnu.org/licenses/
 #include "utils/petutils.h"
 #include "utils/puppetutils.h"
 #include "utils/fishingutils.h"
+#include "utils/gardenutils.h"
 #include "utils/itemutils.h"
 #include "utils/jailutils.h"
 #include "linkshell.h"
 #include "map.h"
+#include "notoriety_container.h"
+#include "roe.h"
+#include "entities/charentity.h"
 #include "entities/mobentity.h"
 #include "entities/npcentity.h"
-#include "entities/charentity.h"
+#include "entities/trustentity.h"
 #include "spell.h"
 #include "utils/synthutils.h"
 #include "trade_container.h"
@@ -65,6 +70,7 @@ along with this program.  If not, see http://www.gnu.org/licenses/
 #include "ai/states/death_state.h"
 
 #include "items/item_shop.h"
+#include "items/item_flowerpot.h"
 
 #include "lua/luautils.h"
 
@@ -132,6 +138,9 @@ along with this program.  If not, see http://www.gnu.org/licenses/
 #include "packets/position.h"
 #include "packets/release.h"
 #include "packets/release_special.h"
+#include "packets/roe_questlog.h"
+#include "packets/roe_sparkupdate.h"
+#include "packets/roe_update.h"
 #include "packets/server_ip.h"
 #include "packets/server_message.h"
 #include "packets/shop_appraise.h"
@@ -216,6 +225,7 @@ void SmallPacket0xFFF(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x00A(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     data.ref<uint32>(0x5C) = 0;
 
     PChar->clearPacketList();
@@ -304,6 +314,11 @@ void SmallPacket0x00A(map_session_data_t* session, CCharEntity* PChar, CBasicPac
     charutils::SaveZonesVisited(PChar);
     charutils::SavePlayTime(PChar);
 
+    if (PChar->m_moghouseID != 0)
+    {
+        gardenutils::UpdateGardening(PChar, false);
+    }
+
     PChar->pushPacket(new CDownloadingDataPacket());
     PChar->pushPacket(new CZoneInPacket(PChar, PChar->m_event.EventID));
     PChar->pushPacket(new CZoneVisitedPacket(PChar));
@@ -320,6 +335,7 @@ void SmallPacket0x00A(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x00C(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     PChar->pushPacket(new CInventorySizePacket(PChar));
     PChar->pushPacket(new CMenuConfigPacket(PChar));
     PChar->pushPacket(new CCharJobsPacket(PChar));
@@ -363,7 +379,7 @@ void SmallPacket0x00C(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x00D(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
-
+    TracyZoneScoped;
     session->blowfish.status = BLOWFISH_WAITING;
 
     PChar->TradePending.clean();
@@ -425,6 +441,18 @@ void SmallPacket0x00D(map_session_data_t* session, CCharEntity* PChar, CBasicPac
         session->shuttingDown = 2;
         Sql_Query(SqlHandle, "UPDATE char_stats SET zoning = 1 WHERE charid = %u", PChar->id);
         charutils::CheckEquipLogic(PChar, SCRIPT_CHANGEZONE, PChar->getZone());
+
+        if (PChar->CraftContainer->getItemsCount() > 0 && PChar->animation == ANIMATION_SYNTH)
+        {
+            // NOTE:
+            // Supposed non-losable items are reportely lost if this condition is met:
+            // https://ffxiclopedia.fandom.com/wiki/Lu_Shang%27s_Fishing_Rod
+            // The broken rod can never be lost in a normal failed synth. It will only be lost if the synth is
+            // interrupted in some way, such as by being attacked or moving to another area (e.g. ship docking).
+
+            ShowExploit(CL_YELLOW "SmallPacket0x00D: %s attempting to zone in the middle of a synth, failing their synth!\n" CL_RESET, PChar->GetName());
+            synthutils::doSynthFail(PChar);
+        }
     }
 
     if (PChar->loc.zone != nullptr)
@@ -434,6 +462,7 @@ void SmallPacket0x00D(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
     charutils::SaveCharStats(PChar);
     charutils::SaveCharExp(PChar, PChar->GetMJob());
+    charutils::SaveEminenceData(PChar);
 
     PChar->status = STATUS_DISAPPEAR;
     return;
@@ -447,6 +476,7 @@ void SmallPacket0x00D(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x00F(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     charutils::SendKeyItems(PChar);
     charutils::SendQuestMissionLog(PChar);
 
@@ -475,6 +505,7 @@ void SmallPacket0x00F(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x011(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     session->blowfish.status = BLOWFISH_ACCEPTED;
 
     PChar->health.tp = 0;
@@ -508,6 +539,9 @@ void SmallPacket0x011(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x015(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
+    TracyZoneCString("Player Sync");
+
     if (PChar->status != STATUS_SHUTDOWN &&
         PChar->status != STATUS_DISAPPEAR)
     {
@@ -564,6 +598,7 @@ void SmallPacket0x015(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x016(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint16 targid = data.ref<uint16>(0x04);
 
     if (targid == PChar->targid)
@@ -599,6 +634,7 @@ void SmallPacket0x016(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x017(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint16 targid = data.ref<uint16>(0x04);
     uint32 npcid = data.ref<uint32>(0x08);
     uint8  type = data.ref<uint8>(0x12);
@@ -613,285 +649,323 @@ void SmallPacket0x017(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 *                                                                       *
 ************************************************************************/
 
-void SmallPacket0x01A(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
+void SmallPacket0x01A(map_session_data_t* PSession, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
+    TracyZoneCString("Player Action");
+
     // uint32 ID = data.ref<uint32>(0x04);
     uint16 TargID = data.ref<uint16>(0x08);
-    uint8  action = data.ref<uint8>(0x0A);
+    uint8 action = data.ref<uint8>(0x0A);
 
     switch (action)
     {
-    case 0x00: // trigger
-    {
-        if (PChar->StatusEffectContainer->HasPreventActionEffect())
-            return;
+        case 0x00: // trigger
+        {
+            if (PChar->StatusEffectContainer->HasPreventActionEffect())
+            {
+                return;
+            }
+
+            if (PChar->m_Costume != 0 || PChar->animation == ANIMATION_SYNTH)
+            {
+                PChar->pushPacket(new CReleasePacket(PChar, RELEASE_STANDARD));
+                return;
+            }
+
+            CBaseEntity* PNpc = nullptr;
+            PNpc = PChar->GetEntity(TargID, TYPE_NPC);
+
+            if (PNpc != nullptr && distance(PNpc->loc.p, PChar->loc.p) <= 10 && (PNpc->PAI->IsSpawned() || PChar->m_moghouseID != 0))
+            {
+                PNpc->PAI->Trigger(PChar->targid);
+            }
+
+            // Releasing a trust
+            // TODO: 0x0c is set to 0x1, not sure if that is relevant or not.
+            if (auto* PTrust = dynamic_cast<CTrustEntity*>(PChar->GetEntity(TargID, TYPE_TRUST)))
+            {
+                PChar->RemoveTrust(PTrust);
+            }
+
+            if (PChar->m_event.EventID == -1)
+            {
+                PChar->m_event.reset();
+                PChar->pushPacket(new CReleasePacket(PChar, RELEASE_STANDARD));
+            }
+        }
+        break;
+        case 0x02: // attack
+        {
+            if (PChar->isMounted())
+            {
+                PChar->StatusEffectContainer->DelStatusEffectSilent(EFFECT_MOUNTED);
+            }
 
-        if (PChar->m_Costume != 0 || PChar->animation == ANIMATION_SYNTH)
+            PChar->PAI->Engage(TargID);
+        }
+        break;
+        case 0x03: // spellcast
         {
-            PChar->pushPacket(new CReleasePacket(PChar, RELEASE_STANDARD));
-            return;
+            auto spellID = static_cast<SpellID>(data.ref<uint16>(0x0C));
+            PChar->PAI->Cast(TargID, spellID);
+        }
+        break;
+        case 0x04: // disengage
+        {
+            PChar->PAI->Disengage();
         }
+        break;
+        case 0x05: // call for help
+        {
+            if (PChar->StatusEffectContainer->HasPreventActionEffect())
+            {
+                return;
+            }
 
-        CBaseEntity* PNpc = nullptr;
-        PNpc = PChar->GetEntity(TargID, TYPE_NPC);
+            if (auto* PMob = dynamic_cast<CMobEntity*>(PChar->GetBattleTarget()))
+            {
+                if (!PMob->CalledForHelp() && PMob->PEnmityContainer->HasID(PChar->id))
+                {
+                    PMob->CallForHelp(true);
+                    PChar->loc.zone->PushPacket(PChar, CHAR_INRANGE_SELF, new CMessageBasicPacket(PChar, PChar, 0, 0, 19));
+                    return;
+                }
+            }
 
-        if (PNpc != nullptr && distance(PNpc->loc.p, PChar->loc.p) <= 10 && (PNpc->PAI->IsSpawned() || PChar->m_moghouseID != 0))
+            PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, 0, 0, 22));
+        }
+        break;
+        case 0x07: // weaponskill
         {
-            PNpc->PAI->Trigger(PChar->targid);
+            uint16 WSkillID = data.ref<uint16>(0x0C);
+            PChar->PAI->WeaponSkill(TargID, WSkillID);
         }
-
-        // Releasing a trust
-        // TODO: 0x0c is set to 0x1, not sure if that is relevant or not.
-        CBaseEntity* PTrust = PChar->GetEntity(TargID, TYPE_TRUST);
-        if (PTrust != nullptr)
+        break;
+        case 0x09: // jobability
         {
-            PChar->RemoveTrust((CTrustEntity*)PTrust);
+            uint16 JobAbilityID = data.ref<uint16>(0x0C);
+            PChar->PAI->Ability(TargID, JobAbilityID);
         }
-
-        if (PChar->m_event.EventID == -1)
+        break;
+        case 0x0B: // homepoint
         {
-            PChar->m_event.reset();
-            PChar->pushPacket(new CReleasePacket(PChar, RELEASE_STANDARD));
+            if (!PChar->isDead())
+            {
+                return;
+            }
+            charutils::HomePoint(PChar);
         }
-    }
-    break;
-    case 0x02: // attack
-    {
-        if (PChar->isMounted())
+        break;
+        case 0x0C: // assist
         {
-            PChar->StatusEffectContainer->DelStatusEffectSilent(EFFECT_MOUNTED);
+            battleutils::assistTarget(PChar, TargID);
         }
-
-        PChar->PAI->Engage(TargID);
-    }
-    break;
-    case 0x03: // spellcast
-    {
-        SpellID spellID = (SpellID)data.ref<uint16>(0x0C);
-        PChar->PAI->Cast(TargID, spellID);
-    }
-    break;
-    case 0x04: // disengage
-    {
-        PChar->PAI->Disengage();
-    }
-    break;
-    case 0x05: // call for help
-    {
-        if(PChar->StatusEffectContainer->HasPreventActionEffect())
-            return;
-
-        if (auto PMob = dynamic_cast<CMobEntity*>(PChar->GetBattleTarget()))
+        break;
+        case 0x0D: // raise menu
         {
-            if (!PMob->CalledForHelp() && PMob->PEnmityContainer->HasID(PChar->id))
+            if (!PChar->m_hasRaise)
             {
-                PMob->CallForHelp(true);
-                PChar->loc.zone->PushPacket(PChar, CHAR_INRANGE_SELF, new CMessageBasicPacket(PChar, PChar, 0, 0, 19));
                 return;
             }
+
+            if (data.ref<uint8>(0x0C) == 0)
+            { // ACCEPTED RAISE
+                PChar->Raise();
+            }
+            else
+            {
+                PChar->m_hasRaise = 0;
+            }
         }
+        break;
+        case 0x0E: // Fishing
+        {
+            if (PChar->StatusEffectContainer->HasPreventActionEffect())
+            {
+                return;
+            }
 
-        PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, 0, 0, 22));
-    }
-    break;
-    case 0x07: // weaponskill
-    {
-        uint16 WSkillID = data.ref<uint16>(0x0C);
-        PChar->PAI->WeaponSkill(TargID, WSkillID);
-    }
-    break;
-    case 0x09: // jobability
-    {
-        uint16 JobAbilityID = data.ref<uint16>(0x0C);
-        PChar->PAI->Ability(TargID, JobAbilityID);
-    }
-    break;
-    case 0x0B: // homepoint
-    {
-        if (!PChar->isDead())
-            return;
-        charutils::HomePoint(PChar);
-    }
-    break;
-    case 0x0C: // assist
-    {
-        battleutils::assistTarget(PChar, TargID);
-    }
-    break;
-    case 0x0D: // raise menu
-    {
-        if (!PChar->m_hasRaise)
-            return;
-        if (data.ref<uint8>(0x0C) == 0) //ACCEPTED RAISE
-            PChar->Raise();
-        else
-            PChar->m_hasRaise = 0;
-    }
-    break;
-    case 0x0E: // Fishing
-    {
-        if(PChar->StatusEffectContainer->HasPreventActionEffect())
-            return;
+            fishingutils::StartFishing(PChar);
+        }
+        break;
+        case 0x0F: // change target
+        {
+            PChar->PAI->ChangeTarget(TargID);
+        }
+        break;
+        case 0x10: // Ranged Attack
+        {
+            uint8 currentAnimation = PChar->animation;
+            if (currentAnimation != ANIMATION_NONE && currentAnimation != ANIMATION_ATTACK)
+            {
+                ShowExploit(CL_YELLOW "SmallPacket0x01A: Player %s trying to Ranged Attack from invalid state\n" CL_RESET, PChar->GetName());
+                return;
+            }
 
-        fishingutils::StartFishing(PChar);
-    }
-    break;
-    case 0x0F: // change target
-    {
-        PChar->PAI->ChangeTarget(TargID);
-    }
-    break;
-    case 0x10: // rangedattack
-    {
-        PChar->PAI->RangedAttack(TargID);
-    }
-    break;
-    case 0x11: // chocobo digging
-    {
-        if (!PChar->isMounted())
-            return;
+            PChar->PAI->RangedAttack(TargID);
+        }
+        break;
+        case 0x11: // chocobo digging
+        {
+            if (!PChar->isMounted())
+            {
+                return;
+            }
 
-        // bunch of gysahl greens
-        uint8 slotID = PChar->getStorage(LOC_INVENTORY)->SearchItem(4545);
+            // bunch of gysahl greens
+            uint8 slotID = PChar->getStorage(LOC_INVENTORY)->SearchItem(4545);
 
-        if (slotID != ERROR_SLOTID)
-        {
-            // attempt to dig
-            if (luautils::OnChocoboDig(PChar, true))
+            if (slotID != ERROR_SLOTID)
             {
-                charutils::UpdateItem(PChar, LOC_INVENTORY, slotID, -1);
+                // attempt to dig
+                if (luautils::OnChocoboDig(PChar, true))
+                {
+                    charutils::UpdateItem(PChar, LOC_INVENTORY, slotID, -1);
 
-                PChar->pushPacket(new CInventoryFinishPacket());
-                PChar->pushPacket(new CChocoboDiggingPacket(PChar));
+                    PChar->pushPacket(new CInventoryFinishPacket());
+                    PChar->pushPacket(new CChocoboDiggingPacket(PChar));
 
-                // dig is possible
-                luautils::OnChocoboDig(PChar, false);
+                    // dig is possible
+                    luautils::OnChocoboDig(PChar, false);
+                }
+                else
+                {
+                    // unable to dig yet
+                    PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, 0, 0, MSGBASIC_WAIT_LONGER));
+                }
             }
-            else {
-                // unable to dig yet
-                PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, 0, 0, MSGBASIC_WAIT_LONGER));
+            else
+            {
+                // You don't have any gysahl greens
+                PChar->pushPacket(new CMessageSystemPacket(4545, 0, 39));
             }
         }
-        else{
-            // You don't have any gysahl greens
-            PChar->pushPacket(new CMessageSystemPacket(4545, 0, 39));
-        }
-    }
-    break;
-    case 0x12: // dismount
-    {
-        if (PChar->StatusEffectContainer->HasPreventActionEffect() || !PChar->isMounted())
-            return;
-
-        PChar->animation = ANIMATION_NONE;
-        PChar->updatemask |= UPDATE_HP;
-        PChar->StatusEffectContainer->DelStatusEffectSilent(EFFECT_MOUNTED);
-    }
-    break;
-    case 0x13: // tractor menu
-    {
-        if (data.ref<uint8>(0x0C) == 0 && PChar->m_hasTractor != 0) //ACCEPTED TRACTOR
+        break;
+        case 0x12: // dismount
         {
-            //PChar->PBattleAI->SetCurrentAction(ACTION_RAISE_MENU_SELECTION);
-            PChar->loc.p = PChar->m_StartActionPos;
-            PChar->loc.destination = PChar->getZone();
-            PChar->status = STATUS_DISAPPEAR;
-            PChar->loc.boundary = 0;
-            PChar->clearPacketList();
-            charutils::SendToZone(PChar, 2, zoneutils::GetZoneIPP(PChar->loc.destination));
-        }
+            if (PChar->StatusEffectContainer->HasPreventActionEffect() || !PChar->isMounted())
+            {
+                return;
+            }
 
-        PChar->m_hasTractor = 0;
-    }
-    break;
-    case 0x14: // complete character update
-    {
-        if (PChar->m_moghouseID != 0)
-        {
-            PChar->loc.zone->SpawnMoogle(PChar);
-        }
-        else{
-            PChar->loc.zone->SpawnPCs(PChar);
-            PChar->loc.zone->SpawnNPCs(PChar);
-            PChar->loc.zone->SpawnMOBs(PChar);
+            PChar->animation = ANIMATION_NONE;
+            PChar->updatemask |= UPDATE_HP;
+            PChar->StatusEffectContainer->DelStatusEffectSilent(EFFECT_MOUNTED);
         }
-    }
-    break;
-    case 0x15: break; // ballista - quarry
-    case 0x16: break; // ballista - sprint
-    case 0x18: // blockaid
-    {
-        if (!PChar->StatusEffectContainer->HasStatusEffect(EFFECT_ALLIED_TAGS))
+        break;
+        case 0x13: // tractor menu
         {
-            uint8 type = data.ref<uint8>(0x0C);
-
-            if (type == 0x00 && PChar->getBlockingAid()) // /blockaid off
+            if (data.ref<uint8>(0x0C) == 0 && PChar->m_hasTractor != 0) // ACCEPTED TRACTOR
             {
-                // Blockaid canceled
-                PChar->pushPacket(new CMessageSystemPacket(0, 0, 222));
-                PChar->setBlockingAid(false);
+                // PChar->PBattleAI->SetCurrentAction(ACTION_RAISE_MENU_SELECTION);
+                PChar->loc.p = PChar->m_StartActionPos;
+                PChar->loc.destination = PChar->getZone();
+                PChar->status = STATUS_DISAPPEAR;
+                PChar->loc.boundary = 0;
+                PChar->clearPacketList();
+                charutils::SendToZone(PChar, 2, zoneutils::GetZoneIPP(PChar->loc.destination));
             }
-            else if (type == 0x01 && !PChar->getBlockingAid()) // /blockaid on
+
+            PChar->m_hasTractor = 0;
+        }
+        break;
+        case 0x14: // complete character update
+        {
+            if (PChar->m_moghouseID != 0)
             {
-                // Blockaid activated
-                PChar->pushPacket(new CMessageSystemPacket(0, 0, 221));
-                PChar->setBlockingAid(true);
+                PChar->loc.zone->SpawnMoogle(PChar);
             }
-            else if (type == 0x02) // /blockaid
+            else
             {
-                // Blockaid is currently active/inactive
-                PChar->pushPacket(new CMessageSystemPacket(0, 0, PChar->getBlockingAid() ? 223 : 224));
+                PChar->loc.zone->SpawnPCs(PChar);
+                PChar->loc.zone->SpawnNPCs(PChar);
+                PChar->loc.zone->SpawnMOBs(PChar);
             }
         }
-        else
-            PChar->pushPacket(new CMessageSystemPacket(0, 0, 142));
-    }
-    break;
-    case 0x1A: // mounts
-    {
-        uint8 MountID = data.ref<uint8>(0x0C);
-
-        if (PChar->animation != ANIMATION_NONE)
-            PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, 0, 0, 71));
-        else if (!PChar->loc.zone->CanUseMisc(MISC_MOUNT))
-            PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, 0, 0, 316));
-        else if (PChar->GetMLevel() < 20)
-            PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, 20, 0, 773));
-        else if (charutils::hasKeyItem(PChar, 3072 + MountID))
+        break;
+        case 0x15: // ballista - quarry
+        case 0x16: // ballista - sprint
+            break;
+        case 0x18: // blockaid
         {
-            if (PChar->PRecastContainer->HasRecast(RECAST_ABILITY, 256, 60))
+            if (!PChar->StatusEffectContainer->HasStatusEffect(EFFECT_ALLIED_TAGS))
             {
-                PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, 0, 0, 94));
+                uint8 type = data.ref<uint8>(0x0C);
 
-                // add recast timer
-                //PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, 0, 0, 202));
-                return;
+                if (type == 0x00 && PChar->getBlockingAid()) // /blockaid off
+                {
+                    // Blockaid canceled
+                    PChar->pushPacket(new CMessageSystemPacket(0, 0, 222));
+                    PChar->setBlockingAid(false);
+                }
+                else if (type == 0x01 && !PChar->getBlockingAid()) // /blockaid on
+                {
+                    // Blockaid activated
+                    PChar->pushPacket(new CMessageSystemPacket(0, 0, 221));
+                    PChar->setBlockingAid(true);
+                }
+                else if (type == 0x02) // /blockaid
+                {
+                    // Blockaid is currently active/inactive
+                    PChar->pushPacket(new CMessageSystemPacket(0, 0, PChar->getBlockingAid() ? 223 : 224));
+                }
+            }
+            else
+            {
+                PChar->pushPacket(new CMessageSystemPacket(0, 0, 142));
+            }
+        }
+        break;
+        case 0x1A: // mounts
+        {
+            uint8 MountID = data.ref<uint8>(0x0C);
+
+            if (PChar->animation != ANIMATION_NONE)
+            {
+                PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, 0, 0, 71));
+            }
+            else if (!PChar->loc.zone->CanUseMisc(MISC_MOUNT))
+            {
+                PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, 0, 0, 316));
+            }
+            else if (PChar->GetMLevel() < 20)
+            {
+                PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, 20, 0, 773));
             }
-            // Retail prevents mounts if a player has enmity on any mob in the zone, need a function for this
-            for (SpawnIDList_t::iterator it = PChar->SpawnMOBList.begin(); it != PChar->SpawnMOBList.end(); ++it)
+            else if (charutils::hasKeyItem(PChar, 3072 + MountID))
             {
-                CMobEntity* PMob = (CMobEntity*)it->second;
+                if (PChar->PRecastContainer->HasRecast(RECAST_ABILITY, 256, 60))
+                {
+                    PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, 0, 0, 94));
+
+                    // add recast timer
+                    // PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, 0, 0, 202));
+                    return;
+                }
 
-                if (PMob->PEnmityContainer->HasID(PChar->id))
+                if (PChar->PNotorietyContainer->hasEnmity())
                 {
                     PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, 0, 0, 339));
                     return;
                 }
+
+                PChar->StatusEffectContainer->AddStatusEffect(
+                    new CStatusEffect(EFFECT_MOUNTED, EFFECT_MOUNTED, (MountID ? ++MountID : 0), 0, 1800),
+                    true);
+                PChar->PRecastContainer->Add(RECAST_ABILITY, 256, 60);
+                PChar->pushPacket(new CCharRecastPacket(PChar));
             }
-            PChar->StatusEffectContainer->AddStatusEffect(new CStatusEffect(EFFECT_MOUNTED, EFFECT_MOUNTED, (MountID ? ++MountID : 0), 0, 1800), true);
-            PChar->PRecastContainer->Add(RECAST_ABILITY, 256, 60);
-            PChar->pushPacket(new CCharRecastPacket(PChar));
         }
+        break;
+        default:
+        {
+            ShowWarning(CL_YELLOW "CLIENT PERFORMING UNHANDLED ACTION %02hX\n" CL_RESET, action);
+            return;
+        }
+        break;
     }
-    break;
-    default:
-    {
-        ShowWarning(CL_YELLOW"CLIENT PERFORMING UNHANDLED ACTION %02hX\n" CL_RESET, action);
-        return;
-    }
-    break;
-    }
-    ShowAction(CL_CYAN"CLIENT %s PERFORMING ACTION %02hX\n" CL_RESET, PChar->GetName(), action);
+    ShowAction(CL_CYAN "CLIENT %s PERFORMING ACTION %02hX\n" CL_RESET, PChar->GetName(), action);
 }
 
 /************************************************************************
@@ -902,6 +976,7 @@ void SmallPacket0x01A(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x01B(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     // 0 - world pass, 2 - gold world pass; +1 - purchase
 
     PChar->pushPacket(new CWorldPassPacket(data.ref<uint8>(0x04) & 1 ? (uint32)tpzrand::GetRandomNumber(9999999999) : 0));
@@ -917,6 +992,7 @@ void SmallPacket0x01B(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x01C(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     PrintPacket(data);
     return;
 }
@@ -929,10 +1005,17 @@ void SmallPacket0x01C(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x028(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     int32  quantity = data.ref<uint8>(0x04);
     uint8 container = data.ref<uint8>(0x08);
     uint8    slotID = data.ref<uint8>(0x09);
 
+    if (container >= MAX_CONTAINER_ID)
+    {
+        ShowExploit(CL_YELLOW "SmallPacket0x028: Invalid container ID passed to packet %u by %s\n" CL_RESET, container, PChar->GetName());
+        return;
+    }
+
     CItem* PItem = PChar->getStorage(container)->GetItem(slotID);
 
     if (PItem != nullptr && !PItem->isSubType(ITEM_LOCKED))
@@ -960,7 +1043,7 @@ void SmallPacket0x028(map_session_data_t* session, CCharEntity* PChar, CBasicPac
         }
         return;
     }
-    ShowWarning(CL_YELLOW"SmallPacket0x028: Attempt of removal nullptr or LOCKED item from slot %u\n" CL_RESET, slotID);
+    ShowExploit(CL_YELLOW "SmallPacket0x028: Attempt of removal nullptr or LOCKED item from slot %u\n" CL_RESET, slotID);
     return;
 }
 
@@ -972,6 +1055,7 @@ void SmallPacket0x028(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x029(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint32 quantity = data.ref<uint8>(0x04);
     uint8  FromLocationID = data.ref<uint8>(0x08);
     uint8  ToLocationID = data.ref<uint8>(0x09);
@@ -1081,6 +1165,7 @@ void SmallPacket0x029(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x032(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint32 charid = data.ref<uint32>(0x04);
     uint16 targid = data.ref<uint16>(0x08);
 
@@ -1137,6 +1222,7 @@ void SmallPacket0x032(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x033(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     CCharEntity* PTarget = (CCharEntity*)PChar->GetEntity(PChar->TradePending.targid, TYPE_PC);
 
     if (PTarget != nullptr && PChar->TradePending.id == PTarget->id)
@@ -1239,6 +1325,7 @@ void SmallPacket0x033(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x034(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint32 quantity = data.ref<uint32>(0x04);
     uint16 itemID = data.ref<uint16>(0x08);
     uint8  invSlotID = data.ref<uint8>(0x0A);
@@ -1327,6 +1414,7 @@ void SmallPacket0x034(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x036(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint32 npcid = data.ref<uint32>(0x04);
     uint16 targid = data.ref<uint16>(0x3A);
 
@@ -1345,22 +1433,25 @@ void SmallPacket0x036(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
             CItem* PItem = PChar->getStorage(LOC_INVENTORY)->GetItem(invSlotID);
 
-            if ((PItem == nullptr) || (PItem->isSubType(ITEM_LOCKED)) || (PItem->getQuantity() < Quantity))
+            if (PItem == nullptr || PItem->getQuantity() < Quantity)
             {
                 ShowError(CL_RED "SmallPacket0x036: Player %s trying to trade invalid item [to NPC]! \n" CL_RESET, PChar->GetName());
-
-                // Leave the items locked so people can't use invalid trade attempts to unlock arbitrary inventory slots
                 return;
             }
-            else
+
+            if (PItem->getReserve() > 0)
             {
-                PChar->TradeContainer->setItem(slotID, PItem->getID(), invSlotID, Quantity, PItem);
-                PItem->setSubType(ITEM_LOCKED);
+                ShowError(CL_RED "SmallPacket0x036: Player %s trying to trade a RESERVED item [to NPC]! \n" CL_RESET, PChar->GetName());
+                return;
             }
+
+            PItem->setReserve(Quantity);
+            PChar->TradeContainer->setItem(slotID, PItem->getID(), invSlotID, Quantity, PItem);
         }
 
         PChar->StatusEffectContainer->DelStatusEffectsByFlag(EFFECTFLAG_DETECTABLE);
         luautils::OnTrade(PChar, PNpc);
+        PChar->TradeContainer->unreserveUnconfirmed();
     }
     return;
 }
@@ -1373,11 +1464,18 @@ void SmallPacket0x036(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x037(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     // uint32 EntityID = data.ref<uint32>(0x04);
     uint16 TargetID = data.ref<uint16>(0x0C);
     uint8  SlotID = data.ref<uint8>(0x0E);
     uint8  StorageID = data.ref<uint8>(0x10);
 
+    if (StorageID >= MAX_CONTAINER_ID)
+    {
+        ShowExploit(CL_YELLOW "SmallPacket0x037: Invalid storage ID passed to packet %u by %s\n" CL_RESET, StorageID, PChar->GetName());
+        return;
+    }
+
     if (PChar->UContainer->GetType() != UCONTAINER_USEITEM)
         PChar->PAI->UseItem(TargetID, StorageID, SlotID);
     else
@@ -1394,7 +1492,18 @@ void SmallPacket0x037(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x03A(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
-    CItemContainer* PItemContainer = PChar->getStorage(data.ref<uint8>(0x04));
+    TracyZoneScoped;
+    TracyZoneCString("Sort Inventory");
+
+    uint8 container = data.ref<uint8>(0x04);
+
+    if (container >= MAX_CONTAINER_ID)
+    {
+        ShowExploit(CL_YELLOW "SmallPacket0x03A: Invalid container ID passed to packet %u by %s\n" CL_RESET, container, PChar->GetName());
+        return;
+    }
+
+    CItemContainer* PItemContainer = PChar->getStorage(container);
 
     uint8 size = PItemContainer->GetSize();
 
@@ -1462,6 +1571,7 @@ void SmallPacket0x03A(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x03C(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     ShowWarning(CL_YELLOW"SmallPacket0x03C\n" CL_RESET);
     return;
 }
@@ -1474,6 +1584,7 @@ void SmallPacket0x03C(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x03D(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     const int8* name = (const int8*)(data[0x08]);
     uint8 cmd = data.ref<uint8>(0x18);
 
@@ -1539,12 +1650,19 @@ void SmallPacket0x03D(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x041(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     PrintPacket(data);
 
-    if (PChar->PTreasurePool != nullptr)
-    {
-        uint8 SlotID = data.ref<uint8>(0x04);
+    uint8 SlotID = data.ref<uint8>(0x04);
+
+    if (SlotID >= TREASUREPOOL_SIZE)
+    {
+        ShowExploit(CL_YELLOW "SmallPacket0x041: Invalid slot ID passed to packet %u by %s\n" CL_RESET, SlotID, PChar->GetName());
+        return;
+    }
 
+    if (PChar->PTreasurePool != nullptr)
+    {
         if (!PChar->PTreasurePool->HasLottedItem(PChar, SlotID))
         {
             PChar->PTreasurePool->LotItem(PChar, SlotID,tpzrand::GetRandomNumber(1,1000)); //1 ~ 998+1
@@ -1560,12 +1678,19 @@ void SmallPacket0x041(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x042(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     PrintPacket(data);
 
-    if (PChar->PTreasurePool != nullptr)
+    uint8 SlotID = data.ref<uint8>(0x04);
+
+    if (SlotID >= TREASUREPOOL_SIZE)
     {
-        uint8 SlotID = data.ref<uint8>(0x04);
+        ShowExploit(CL_YELLOW "SmallPacket0x042: Invalid slot ID passed to packet %u by %s\n" CL_RESET, SlotID, PChar->GetName());
+        return;
+    }
 
+    if (PChar->PTreasurePool != nullptr)
+    {
         if (!PChar->PTreasurePool->HasPassedItem(PChar, SlotID))
         {
             PChar->PTreasurePool->PassItem(PChar, SlotID);
@@ -1581,6 +1706,7 @@ void SmallPacket0x042(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x04B(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     // uint8   msg_chunk = data.ref<uint8>(0x04); // The current chunk of the message to send.. (1 = start, 2 = rest of message)
     // uint8   msg_unknown1 = data.ref<uint8>(0x05); // Unknown.. always 0
     // uint8   msg_unknown2 = data.ref<uint8>(0x06); // Unknown.. always 1
@@ -1618,6 +1744,7 @@ void SmallPacket0x04B(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x04D(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint8 action = data.ref<uint8>(0x04);
     uint8 boxtype = data.ref<uint8>(0x05);
     uint8 slotID = data.ref<uint8>( 0x06);
@@ -2262,6 +2389,7 @@ void SmallPacket0x04D(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x04E(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint8  action = data.ref<uint8>(0x04);
     uint8  slotid = data.ref<uint8>(0x05);
     uint32 price = data.ref<uint32>(0x08);
@@ -2554,6 +2682,7 @@ void SmallPacket0x04E(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x050(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     if (PChar->status != STATUS_NORMAL)
         return;
 
@@ -2584,6 +2713,7 @@ void SmallPacket0x050(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x051(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     if (PChar->status != STATUS_NORMAL)
         return;
 
@@ -2612,6 +2742,7 @@ void SmallPacket0x051(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x052(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     //Im guessing this is here to check if you can use A Item, as it seems useless to have this sent to server
     //as It will check requirements when it goes to equip the items anyway
     //0x05 is slot of updated item
@@ -2631,6 +2762,7 @@ void SmallPacket0x052(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 ************************************************************************/
 void SmallPacket0x053(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint8 count = data.ref<uint8>(0x04);
     uint8 type = data.ref<uint8>(0x05);
 
@@ -2710,6 +2842,7 @@ void SmallPacket0x053(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x058(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint16 skillID    = data.ref<uint16>(0x04);
     uint16 skillLevel = data.ref<uint16>(0x06);
 
@@ -2724,6 +2857,7 @@ void SmallPacket0x058(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x059(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     if (PChar->animation == ANIMATION_SYNTH)
     {
         synthutils::sendSynthDone(PChar);
@@ -2739,6 +2873,7 @@ void SmallPacket0x059(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x05A(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     PChar->pushPacket(new CConquestPacket(PChar));
     PChar->pushPacket(new CCampaignPacket(PChar, 0));
     PChar->pushPacket(new CCampaignPacket(PChar, 1));
@@ -2757,6 +2892,7 @@ void SmallPacket0x05A(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x05B(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     //auto CharID = data.ref<uint32>(0x04);
     auto Result = data.ref<uint32>(0x08);
     //auto ZoneID = data.ref<uint16>(0x10);
@@ -2777,6 +2913,7 @@ void SmallPacket0x05B(map_session_data_t* session, CCharEntity* PChar, CBasicPac
             //reset if this event did not initiate another event
             if (PChar->m_event.EventID == EventID)
             {
+                PChar->m_Substate = CHAR_SUBSTATE::SUBSTATE_NONE;
                 PChar->m_event.reset();
             }
         }
@@ -2794,6 +2931,7 @@ void SmallPacket0x05B(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x05C(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     //auto CharID = data.ref<uint32>(0x10);
     auto Result = data.ref<uint32>(0x14);
     //auto ZoneID = data.ref<uint16>(0x18);
@@ -2814,6 +2952,7 @@ void SmallPacket0x05C(map_session_data_t* session, CCharEntity* PChar, CBasicPac
             updatePosition = luautils::OnEventFinish(PChar, EventID, Result) == 1;
             if (PChar->m_event.EventID == EventID)
             {
+                PChar->m_Substate = CHAR_SUBSTATE::SUBSTATE_NONE;
                 PChar->m_event.reset();
             }
         }
@@ -2841,6 +2980,7 @@ void SmallPacket0x05C(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x05D(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     if (jailutils::InPrison(PChar))
     {
         PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, 0, 0, 316));
@@ -2852,6 +2992,19 @@ void SmallPacket0x05D(map_session_data_t* session, CCharEntity* PChar, CBasicPac
     const auto EmoteID = data.ref<Emote>(0x0A);
     const auto emoteMode = data.ref<EmoteMode>(0x0B);
 
+    // Rate limit emotes
+    auto lastEmoteTime = PChar->GetLocalVar("LastEmoteTime");
+    auto timeNowSeconds = std::chrono::time_point_cast<std::chrono::seconds>(server_clock::now());
+    if (lastEmoteTime == 0 || (timeNowSeconds.time_since_epoch().count() - lastEmoteTime) > 2)
+    {
+        PChar->SetLocalVar("LastEmoteTime", (uint32)timeNowSeconds.time_since_epoch().count());
+    }
+    else
+    {
+        ShowWarning(CL_YELLOW "SmallPacket0x05D: Rate limiting emote packet for %s\n" CL_RESET, PChar->GetName());
+        return;
+    }
+
     // Invalid Emote ID.
     if (EmoteID < Emote::POINT || EmoteID > Emote::JOB)
     {
@@ -2871,7 +3024,7 @@ void SmallPacket0x05D(map_session_data_t* session, CCharEntity* PChar, CBasicPac
     {
         return;
     }
-    
+
     PChar->loc.zone->PushPacket(PChar, CHAR_INRANGE_SELF, new CCharEmotionPacket(PChar, TargetID, TargetIndex, EmoteID, emoteMode, extra));
 
     luautils::OnPlayerEmote(PChar, EmoteID);
@@ -2885,6 +3038,8 @@ void SmallPacket0x05D(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x05E(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
+
     // handle pets on zone
     if (PChar->PPet != nullptr)
     {
@@ -2893,9 +3048,10 @@ void SmallPacket0x05E(map_session_data_t* session, CCharEntity* PChar, CBasicPac
     }
 
     uint32 zoneLineID = data.ref<uint32>(0x04);
-    //TODO: verify packet in adoulin expansion
     uint8  town = data.ref<uint8>(0x16);
-    uint8  zone = data.ref<uint8>(0x17);
+    uint8  requestedZone = data.ref<uint8>(0x17);
+
+    uint16 startingZone = PChar->getZone();
 
     PChar->ClearTrusts();
 
@@ -2907,33 +3063,58 @@ void SmallPacket0x05E(map_session_data_t* session, CCharEntity* PChar, CBasicPac
         // Exiting Mog House..
         if (zoneLineID == 1903324538)
         {
-            uint16 prevzone = PChar->getZone();
+            uint16 destinationZone = PChar->getZone();
             // Note: zone zero actually exists but is unused in retail, we should stop using zero someday.
             // If zero, return to previous zone.. otherwise, determine the zone..
-            if (zone != 0)
+            if (requestedZone != 0)
             {
                 switch (town)
                 {
-                case 1: prevzone = zone + 0xE5; break;
-                case 2: prevzone = zone + 0xE9; break;
-                case 3: prevzone = zone + 0xED; break;
-                case 4: prevzone = zone + 0xF2; break;
-                case 5: prevzone = zone + (zone == 1 ? 0x2F : 0x30); break;
+                case 1: destinationZone = requestedZone + ZONE_SOUTHERN_SANDORIA - 1; break;
+                case 2: destinationZone = requestedZone + ZONE_BASTOK_MINES - 1; break;
+                case 3: destinationZone = requestedZone + ZONE_WINDURST_WATERS - 1; break;
+                case 4: destinationZone = requestedZone + ZONE_RULUDE_GARDENS - 1; break;
+                case 5: destinationZone = requestedZone + (requestedZone == 1 ? ZONE_AL_ZAHBI - 1 : ZONE_AHT_URHGAN_WHITEGATE - 2); break;
                 }
 
                 // Handle case for mog garden.. (Above addition does not work for this zone.)
-                if (zone == 127)
+                if (requestedZone == 127)
                 {
-                    prevzone = 280;
+                    destinationZone = ZONE_MOG_GARDEN;
                 }
-                else if (zone == 125)
+                else if (requestedZone == 125) // Go to second floor
                 {
-                    prevzone = PChar->getZone();
+                    destinationZone = PChar->getZone();
                 }
             }
-            PChar->m_moghouseID = 0;
-            PChar->loc.destination = prevzone;
-            memset(&PChar->loc.p, 0, sizeof(PChar->loc.p));
+
+            bool moghouseExitRegular = requestedZone == 0 && PChar->m_moghouseID > 0;
+
+            auto startingRegion = zoneutils::GetCurrentRegion(startingZone);
+            auto destinationRegion = zoneutils::GetCurrentRegion(destinationZone);
+            auto moghouseExitRegions = { REGION_SANDORIA, REGION_BASTOK, REGION_WINDURST, REGION_JEUNO, REGION_WEST_AHT_URHGAN };
+            auto moghouseQuestComplete = PChar->profile.mhflag & (town ? 0x01 << (town - 1) : 0);
+            bool moghouseExitQuestZoneline =
+                moghouseQuestComplete &&
+                startingRegion == destinationRegion &&
+                PChar->m_moghouseID > 0 &&
+                std::any_of(moghouseExitRegions.begin(), moghouseExitRegions.end(), [&destinationRegion](REGIONTYPE acceptedReg) { return destinationRegion == acceptedReg; });
+
+            bool moghouseExitMogGardenZoneline = destinationZone == ZONE_MOG_GARDEN && PChar->m_moghouseID > 0;
+
+            // Validate travel
+            if (moghouseExitRegular || moghouseExitQuestZoneline || moghouseExitMogGardenZoneline)
+            {
+                PChar->m_moghouseID = 0;
+                PChar->loc.destination = destinationZone;
+                memset(&PChar->loc.p, 0, sizeof(PChar->loc.p));
+            }
+            else
+            {
+                PChar->status = STATUS_NORMAL;
+                ShowWarning(CL_YELLOW "SmallPacket0x05E: Moghouse zoneline abuse by %s\n" CL_RESET, PChar->GetName());
+                return;
+            }
         }
         else
         {
@@ -2986,6 +3167,13 @@ void SmallPacket0x05E(map_session_data_t* session, CCharEntity* PChar, CBasicPac
     }
     PChar->clearPacketList();
 
+    if (PChar->loc.destination >= MAX_ZONEID)
+    {
+        ShowWarning(CL_YELLOW "SmallPacket0x05E: Invalid destination passed to packet %u by %s\n" CL_RESET, PChar->loc.destination, PChar->GetName());
+        PChar->loc.destination = startingZone;
+        return;
+    }
+
     uint64 ipp = zoneutils::GetZoneIPP(PChar->loc.destination == 0 ? PChar->getZone() : PChar->loc.destination);
 
     charutils::SendToZone(PChar, 2, ipp);
@@ -3003,6 +3191,7 @@ void SmallPacket0x05E(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x060(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     // uint32 charid = data.ref<uint32>(0x04);
     int8* string = data[12];
     luautils::OnEventUpdate(PChar, string);
@@ -3021,6 +3210,7 @@ void SmallPacket0x060(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x061(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     PChar->pushPacket(new CCharUpdatePacket(PChar));
     PChar->pushPacket(new CCharHealthPacket(PChar));
     PChar->pushPacket(new CCharStatsPacket(PChar));
@@ -3042,6 +3232,7 @@ void SmallPacket0x061(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x063(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     return;
 }
 
@@ -3053,6 +3244,7 @@ void SmallPacket0x063(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x064(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint8 KeyTable = data.ref<uint8>(0x4A);
 
     if (KeyTable >= PChar->keys.tables.size())
@@ -3072,6 +3264,7 @@ void SmallPacket0x064(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x066(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     //PrintPacket(data);
 
     //uint32 charid = data.ref<uint32>(0x04);
@@ -3096,6 +3289,7 @@ void SmallPacket0x066(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x06E(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint32 charid = data.ref<uint32>(0x04);
     uint16 targid = data.ref<uint16>(0x08);
     // cannot invite yourself
@@ -3269,6 +3463,7 @@ void SmallPacket0x06E(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x06F(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     if (PChar->PParty)
         switch (data.ref<uint8>(0x04))
     {
@@ -3328,6 +3523,7 @@ void SmallPacket0x06F(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x070(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     if (PChar->PParty && PChar->PParty->GetLeader() == PChar)
         switch (data.ref<uint8>(0x04))
     {
@@ -3364,6 +3560,7 @@ void SmallPacket0x070(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x071(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     switch (data.ref<uint8>(0x0A))
     {
     case 0: // party - party leader may remove member of his own party
@@ -3515,6 +3712,7 @@ void SmallPacket0x071(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x074(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     CCharEntity* PInviter = zoneutils::GetCharFromWorld(PChar->InvitePending.id, PChar->InvitePending.targid);
 
     uint8 InviteAnswer = data.ref<uint8>(0x04);
@@ -3624,6 +3822,7 @@ void SmallPacket0x074(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x076(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     if (PChar->PParty)
     {
         PChar->PParty->ReloadPartyMembers(PChar);
@@ -3644,6 +3843,7 @@ void SmallPacket0x076(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x077(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     switch (data.ref<uint8>(0x14))
     {
     case 0: // party
@@ -3712,6 +3912,7 @@ void SmallPacket0x077(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x078(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     PChar->pushPacket(new CPartySearchPacket(PChar));
     return;
 }
@@ -3724,6 +3925,7 @@ void SmallPacket0x078(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x083(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint8  quantity = data.ref<uint8>(0x04);
     uint8  shopSlotID = data.ref<uint8>(0x0A);
 
@@ -3778,6 +3980,7 @@ void SmallPacket0x083(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x084(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     if (PChar->animation != ANIMATION_SYNTH)
     {
         uint32 quantity = data.ref<uint32>(0x04);
@@ -3807,6 +4010,7 @@ void SmallPacket0x084(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x085(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     // Retrieve item-to-sell from last slot of the shop's container
     uint32 quantity = PChar->Container->getQuantity(PChar->Container->getExSize());
     uint16 itemID = PChar->Container->getItemID(PChar->Container->getExSize());
@@ -3819,13 +4023,13 @@ void SmallPacket0x085(map_session_data_t* session, CCharEntity* PChar, CBasicPac
     {
         if (quantity < 1 || quantity > PItem->getStackSize()) // Possible exploit
         {
-            ShowError(CL_RED"SmallPacket0x085: Player %s trying to sell invalid quantity %u of itemID %u [to VENDOR] \n" CL_RESET, PChar->GetName(), quantity);
+            ShowExploit(CL_RED"SmallPacket0x085: Player %s trying to sell invalid quantity %u of itemID %u [to VENDOR] \n" CL_RESET, PChar->GetName(), quantity);
             return;
         }
 
         if (PItem->isSubType(ITEM_LOCKED)) // Possible exploit
         {
-            ShowError(CL_RED"SmallPacket0x085: Player %s trying to sell %u of a LOCKED item! ID %i [to VENDOR] \n" CL_RESET, PChar->GetName(), quantity, PItem->getID());
+            ShowExploit(CL_RED"SmallPacket0x085: Player %s trying to sell %u of a LOCKED item! ID %i [to VENDOR] \n" CL_RESET, PChar->GetName(), quantity, PItem->getID());
             return;
         }
 
@@ -3853,6 +4057,7 @@ void SmallPacket0x085(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x096(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     if (jailutils::InPrison(PChar))
     {
         // Prevent crafting in prison
@@ -3911,6 +4116,7 @@ void SmallPacket0x096(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0AA(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint16 itemID = data.ref<uint16>(0x04);
     uint8  quantity = data.ref<uint8>(0x07);
     uint8  shopSlotID = PChar->PGuildShop->SearchItem(itemID);
@@ -3958,6 +4164,7 @@ void SmallPacket0x0AA(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0A2(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint16 diceroll = tpzrand::GetRandomNumber(1000);
 
     PChar->loc.zone->PushPacket(PChar, CHAR_INRANGE_SELF, new CMessageStandardPacket(PChar, diceroll, MsgStd::DiceRoll));
@@ -3972,6 +4179,7 @@ void SmallPacket0x0A2(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0AB(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     if (PChar->PGuildShop != nullptr)
     {
         PChar->pushPacket(new CGuildMenuBuyPacket(PChar, PChar->PGuildShop));
@@ -3987,6 +4195,7 @@ void SmallPacket0x0AB(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0AC(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     if (PChar->animation != ANIMATION_SYNTH)
     {
         if (PChar->PGuildShop != nullptr)
@@ -4029,6 +4238,7 @@ void SmallPacket0x0AC(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0AD(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     if (PChar->PGuildShop != nullptr)
     {
         PChar->pushPacket(new CGuildMenuSellPacket(PChar, PChar->PGuildShop));
@@ -4044,6 +4254,7 @@ void SmallPacket0x0AD(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0B5(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     if (data.ref<uint8>(0x06) == '!' && !jailutils::InPrison(PChar) && CmdHandler.call(PChar, (const int8*)data[7]) == 0)
     {
         //this makes sure a command isn't sent to chat
@@ -4264,6 +4475,7 @@ void SmallPacket0x0B5(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0B6(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     if (jailutils::InPrison(PChar))
     {
         PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, 0, 0, 316));
@@ -4303,7 +4515,7 @@ void SmallPacket0x0B6(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0BE(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
-
+    TracyZoneScoped;
     uint8 operation = data.ref<uint8>(0x05);
 
     switch (data.ref<uint8>(0x04))
@@ -4370,6 +4582,7 @@ void SmallPacket0x0BE(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0C3(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint8 lsNum = data.ref<uint8>(0x05);
     CItemLinkshell* PItemLinkshell = (CItemLinkshell*)PChar->getEquip(SLOT_LINK1);
     if (lsNum == 2)
@@ -4399,6 +4612,7 @@ void SmallPacket0x0C3(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0C4(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint8 SlotID = data.ref<uint8>(0x06);
     uint8 LocationID = data.ref<uint8>(0x07);
     uint8 action = data.ref<uint8>(0x08);
@@ -4549,6 +4763,7 @@ void SmallPacket0x0C4(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0CB(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     if (data.ref<uint8>(0x04) == 1)
     {
         //open
@@ -4571,6 +4786,7 @@ void SmallPacket0x0CB(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0D2(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     PChar->ForAlliance([PChar](CBattleEntity* PPartyMember)
     {
         if (PPartyMember->getZone() == PChar->getZone() && ((CCharEntity*)PPartyMember)->m_moghouseID == PChar->m_moghouseID)
@@ -4591,6 +4807,7 @@ void SmallPacket0x0D2(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0D3(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     return;
 }
 
@@ -4602,6 +4819,7 @@ void SmallPacket0x0D3(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0DB(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     PChar->search.language = data.ref<uint8>(0x24);
     return;
 }
@@ -4614,6 +4832,7 @@ void SmallPacket0x0DB(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0DC(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     switch (data.ref<uint32>(0x04))
     {
     case NFLAG_INVITE:
@@ -4724,6 +4943,7 @@ void SmallPacket0x0DC(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0DD(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint32 id = data.ref<uint32>(0x04);
     uint16 targid = data.ref<uint16>(0x08);
     uint8 type = data.ref<uint8>(0x0C);
@@ -4876,6 +5096,7 @@ void SmallPacket0x0DD(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0DE(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     PChar->bazaar.message.clear();
     PChar->bazaar.message.insert(0, (const char*)data[4]);
 
@@ -4894,6 +5115,7 @@ void SmallPacket0x0DE(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0E0(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     PChar->search.message.clear();
     PChar->search.message.insert(0, (const char*)data[4]);
 
@@ -4953,6 +5175,7 @@ void SmallPacket0x0E0(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0E1(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint8 slot = data.ref<uint8>(0x07);
     if (slot == PChar->equip[SLOT_LINK1] && PChar->PLinkshell1)
     {
@@ -4973,6 +5196,7 @@ void SmallPacket0x0E1(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0E2(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     CItemLinkshell* PItemLinkshell = (CItemLinkshell*)PChar->getEquip(SLOT_LINK1);
 
     if (PChar->PLinkshell1 != nullptr && (PItemLinkshell != nullptr && PItemLinkshell->isType(ITEM_LINKSHELL)))
@@ -5024,6 +5248,7 @@ void SmallPacket0x0E2(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0E7(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     if (PChar->status != STATUS_NORMAL)
         return;
 
@@ -5072,6 +5297,7 @@ void SmallPacket0x0E7(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0E8(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     if (PChar->status != STATUS_NORMAL)
         return;
 
@@ -5119,6 +5345,7 @@ void SmallPacket0x0E8(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0EA(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     if (PChar->status != STATUS_NORMAL)
         return;
 
@@ -5138,6 +5365,7 @@ void SmallPacket0x0EA(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0EB(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     if (PChar->m_event.EventID == -1)
         return;
 
@@ -5153,6 +5381,7 @@ void SmallPacket0x0EB(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0F1(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint16 IconID = data.ref<uint16>(0x04);
 
     if (IconID)
@@ -5169,6 +5398,7 @@ void SmallPacket0x0F1(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0F2(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     PChar->loc.boundary = data.ref<uint16>(0x06);
 
     charutils::SaveCharPosition(PChar);
@@ -5183,167 +5413,9 @@ void SmallPacket0x0F2(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0F4(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
-    // Set Widescan range
-    // Distances need verified, based current values off what we had in traits.sql and data at http://wiki.ffxiclopedia.org/wiki/Wide_Scan
-    // NOTE: Widescan was formerly piggy backed onto traits (resist slow) but is not a real trait, any attempt to give it a trait will place a dot on characters trait menu.
-    if (map_config.all_jobs_widescan == 0)
-    {
-        // Limit to BST and RNG, and try to use old distance values for tiers
-        if (PChar->GetMJob() == JOB_RNG)
-        {
-            if (PChar->GetMLevel() >= 60)
-            {
-                PChar->loc.zone->WideScan(PChar, 300);
-            }
-            else if (PChar->GetMLevel() >= 40)
-            {
-                PChar->loc.zone->WideScan(PChar, 250);
-            }
-            else if (PChar->GetMLevel() >= 20)
-            {
-                PChar->loc.zone->WideScan(PChar, 200);
-            }
-            else
-            {
-                PChar->loc.zone->WideScan(PChar, 150);
-            }
-        }
-        else if (PChar->GetMJob() == JOB_BST)
-        {
-            if (PChar->GetMLevel() >= 60)
-            {
-                PChar->loc.zone->WideScan(PChar, 250);
-            }
-            else if (PChar->GetMLevel() >= 40)
-            {
-                PChar->loc.zone->WideScan(PChar, 200);
-            }
-            else if (PChar->GetMLevel() >= 20)
-            {
-                PChar->loc.zone->WideScan(PChar, 150);
-            }
-            else
-            {
-                PChar->loc.zone->WideScan(PChar, 50);
-            }
-        }
-        else if (PChar->GetSJob() == JOB_RNG)
-        {
-            if (PChar->GetSLevel() >= 40)
-            {
-                PChar->loc.zone->WideScan(PChar, 250);
-            }
-            else if (PChar->GetSLevel() >= 20)
-            {
-                PChar->loc.zone->WideScan(PChar, 200);
-            }
-            else
-            {
-                PChar->loc.zone->WideScan(PChar, 150);
-            }
-        }
-        else if (PChar->GetSJob() == JOB_BST)
-        {
-            if (PChar->GetSLevel() >= 40)
-            {
-                PChar->loc.zone->WideScan(PChar, 200);
-            }
-            else if (PChar->GetSLevel() >= 20)
-            {
-                PChar->loc.zone->WideScan(PChar, 150);
-            }
-            else
-            {
-                PChar->loc.zone->WideScan(PChar, 50);
-            }
-        }
-        else
-        {
-            // Not BST or RNG, get nothing!
-            PChar->loc.zone->WideScan(PChar, 0);
-            // The zero needs set or client will lag on map screen saying downloading data.
-        }
-    }
-    else if (map_config.all_jobs_widescan == 1)
-    {
-        // All jobs have 1st tier, and use current retail distance values for tiers
-        if (PChar->GetMJob() == JOB_RNG)
-        {
-            // Need verification
-            // if (PChar->GetMLevel() >= 80)
-            // {
-            //     PChar->loc.zone->WideScan(PChar,350);
-            // }
-            // else if (PChar->GetMLevel() >= 60)
-            if (PChar->GetMLevel() >= 60)
-            {
-                PChar->loc.zone->WideScan(PChar, 300);
-            }
-            else if (PChar->GetMLevel() >= 40)
-            {
-                PChar->loc.zone->WideScan(PChar, 250);
-            }
-            else if (PChar->GetMLevel() >= 20)
-            {
-                PChar->loc.zone->WideScan(PChar, 200);
-            }
-            else
-            {
-                PChar->loc.zone->WideScan(PChar, 150);
-            }
-        }
-        else if (PChar->GetMJob() == JOB_BST)
-        {
-            if (PChar->GetMLevel() >= 80)
-            {
-                PChar->loc.zone->WideScan(PChar, 300);
-            }
-            else if (PChar->GetMLevel() >= 60)
-            {
-                PChar->loc.zone->WideScan(PChar, 250);
-            }
-            else if (PChar->GetMLevel() >= 40)
-            {
-                PChar->loc.zone->WideScan(PChar, 200);
-            }
-            else
-            {
-                PChar->loc.zone->WideScan(PChar, 150);
-            }
-        }
-        else if (PChar->GetSJob() == JOB_RNG)
-        {
-            if (PChar->GetSLevel() >= 40)
-            {
-                PChar->loc.zone->WideScan(PChar, 250);
-            }
-            else if (PChar->GetSLevel() >= 20)
-            {
-                PChar->loc.zone->WideScan(PChar, 200);
-            }
-            else
-            {
-                PChar->loc.zone->WideScan(PChar, 150);
-            }
-        }
-        else if (PChar->GetSJob() == JOB_BST)
-        {
-            if (PChar->GetSLevel() >= 40)
-            {
-                PChar->loc.zone->WideScan(PChar, 200);
-            }
-            else
-            {
-                PChar->loc.zone->WideScan(PChar, 150);
-            }
-        }
-        else
-        {
-            // Not BST or RNG, get base scan radius only!
-            PChar->loc.zone->WideScan(PChar, 150);
-        }
-    }
-    return;
+    TracyZoneScoped;
+    TracyZoneCString("Wide Scan");
+    PChar->loc.zone->WideScan(PChar, charutils::getWideScanRange(PChar));
 }
 
 /************************************************************************
@@ -5354,9 +5426,26 @@ void SmallPacket0x0F4(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0F5(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint16 TargID = data.ref<uint16>(0x04);
 
-    PChar->PWideScanTarget = PChar->GetEntity(TargID, TYPE_MOB | TYPE_NPC);
+    CBaseEntity* target = PChar->GetEntity(TargID, TYPE_MOB | TYPE_NPC);
+    if (target == nullptr)
+    {
+        // Target not found
+        PChar->PWideScanTarget = nullptr;
+        return;
+    }
+
+    uint16 widescanRange = charutils::getWideScanRange(PChar);
+    float dist = distance(PChar->loc.p, target->loc.p);
+
+    // Only allow players to track targets that are actually scannable, and within their wide scan range
+    if (target->isWideScannable() && dist <= widescanRange)
+    {
+        PChar->PWideScanTarget = target;
+    }
+
     return;
 }
 
@@ -5368,6 +5457,7 @@ void SmallPacket0x0F5(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0F6(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     PChar->PWideScanTarget = nullptr;
     return;
 }
@@ -5380,6 +5470,7 @@ void SmallPacket0x0F6(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0FA(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint16 ItemID = data.ref<uint16>(0x04);
 
     if (ItemID == 0)
@@ -5488,6 +5579,7 @@ void SmallPacket0x0FA(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x0FB(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint16 ItemID = data.ref<uint16>(0x04);
 
     if (ItemID == 0)
@@ -5561,6 +5653,237 @@ void SmallPacket0x0FB(map_session_data_t* session, CCharEntity* PChar, CBasicPac
     return;
 }
 
+/************************************************************************
+*                                                                       *
+*  Mog House Plant Flowerpot
+*                                                                       *
+************************************************************************/
+
+void SmallPacket0x0FC(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
+{
+    TracyZoneScoped;
+    uint16 potItemID = data.ref<uint16>(0x04);
+    uint16 itemID = data.ref<uint16>(0x06);
+
+    if (potItemID == 0 || itemID == 0)
+        return;
+
+    uint8 potSlotID = data.ref<uint8>(0x08);
+    uint8 slotID = data.ref<uint8>(0x09);
+    uint8 potContainerID = data.ref<uint8>(0x0A);
+    uint8 containerID = data.ref<uint8>(0x0B);
+
+    if ((potContainerID != LOC_MOGSAFE && potContainerID != LOC_MOGSAFE2) || (containerID != LOC_MOGSAFE && containerID != LOC_MOGSAFE2))
+        return;
+
+    CItemContainer* PPotItemContainer = PChar->getStorage(potContainerID);
+    CItemFlowerpot* PPotItem = (CItemFlowerpot*)PPotItemContainer->GetItem(potSlotID);
+    if (PPotItem == nullptr)
+        return;
+
+    CItemContainer* PItemContainer = PChar->getStorage(containerID);
+    CItem* PItem = PItemContainer->GetItem(slotID);
+    if (PItem == nullptr || PItem->getQuantity() < 1)
+        return;
+
+    if (CItemFlowerpot::getPlantFromSeed(itemID) != FLOWERPOT_PLANT_NONE)
+    {
+        // Planting a seed in the flowerpot
+        PChar->pushPacket(new CMessageStandardPacket(itemID, 132)); // "Your moogle plants the <seed> in the flowerpot."
+        PPotItem->cleanPot();
+        PPotItem->setPlant(CItemFlowerpot::getPlantFromSeed(itemID));
+        PPotItem->setPlantTimestamp(CVanaTime::getInstance()->getVanaTime());
+        PPotItem->setStrength(tpzrand::GetRandomNumber(32));
+        gardenutils::GrowToNextStage(PPotItem);
+    }
+    else if (itemID >= 4096 && itemID <= 4111)
+    {
+        // Feeding the plant a crystal
+        PChar->pushPacket(new CMessageStandardPacket(itemID, 136)); // "Your moogle uses the <item> on the plant."
+        if (PPotItem->getStage() == FLOWERPOT_STAGE_FIRST_SPROUTS_CRYSTAL)
+        {
+            PPotItem->setFirstCrystalFeed(CItemFlowerpot::getElementFromItem(itemID));
+        }
+        else if (PPotItem->getStage() == FLOWERPOT_STAGE_SECOND_SPROUTS_CRYSTAL)
+        {
+            PPotItem->setSecondCrystalFeed(CItemFlowerpot::getElementFromItem(itemID));
+        }
+        gardenutils::GrowToNextStage(PPotItem, true);
+        PPotItem->markExamined();
+    }
+
+    char extra[sizeof(PPotItem->m_extra) * 2 + 1];
+    Sql_EscapeStringLen(SqlHandle, extra, (const char*)PPotItem->m_extra, sizeof(PPotItem->m_extra));
+    const char* Query = "UPDATE char_inventory SET extra = '%s' WHERE charid = %u AND location = %u AND slot = %u";
+    Sql_Query(SqlHandle, Query, extra, PChar->id, PPotItem->getLocationID(), PPotItem->getSlotID());
+
+    PChar->pushPacket(new CFurnitureInteractPacket(PPotItem, potContainerID, potSlotID));
+
+    PChar->pushPacket(new CInventoryItemPacket(PPotItem, potContainerID, potSlotID));
+
+    charutils::UpdateItem(PChar, containerID, slotID, -1);
+    PChar->pushPacket(new CInventoryFinishPacket());
+}
+
+/************************************************************************
+*                                                                       *
+*  Mog House Examine Flowerpot
+*                                                                       *
+************************************************************************/
+
+void SmallPacket0x0FD(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
+{
+    TracyZoneScoped;
+    uint16 itemID = data.ref<uint16>(0x04);
+    if (itemID == 0)
+        return;
+
+    uint8 slotID = data.ref<uint8>(0x06);
+    uint8 containerID = data.ref<uint8>(0x07);
+    if (containerID != LOC_MOGSAFE && containerID != LOC_MOGSAFE2)
+        return;
+
+    CItemContainer* PItemContainer = PChar->getStorage(containerID);
+    CItemFlowerpot* PItem = (CItemFlowerpot*)PItemContainer->GetItem(slotID);
+    if (PItem == nullptr)
+        return;
+
+    if (PItem->isPlanted())
+    {
+        PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, CItemFlowerpot::getSeedID(PItem->getPlant()), 0, MSGBASIC_GARDENING_SEED_SOWN));
+        if (PItem->isTree())
+        {
+            if (PItem->getStage() > FLOWERPOT_STAGE_FIRST_SPROUTS_CRYSTAL)
+            {
+                if (PItem->getExtraCrystalFeed() != FLOWERPOT_ELEMENT_NONE)
+                    PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, CItemFlowerpot::getItemFromElement(PItem->getExtraCrystalFeed()), 0, MSGBASIC_GARDENING_CRYSTAL_USED));
+                else
+                    PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, 0, 0, MSGBASIC_GARDENING_CRYSTAL_NONE));
+            }
+        }
+        if (PItem->getStage() > FLOWERPOT_STAGE_SECOND_SPROUTS_CRYSTAL)
+        {
+            if (PItem->getCommonCrystalFeed() != FLOWERPOT_ELEMENT_NONE)
+                PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, CItemFlowerpot::getItemFromElement(PItem->getCommonCrystalFeed()), 0, MSGBASIC_GARDENING_CRYSTAL_USED));
+            else
+                PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, 0, 0, MSGBASIC_GARDENING_CRYSTAL_NONE));
+        }
+
+        if (!PItem->wasExamined())
+        {
+            PItem->markExamined();
+            char extra[sizeof(PItem->m_extra) * 2 + 1];
+            Sql_EscapeStringLen(SqlHandle, extra, (const char*)PItem->m_extra, sizeof(PItem->m_extra));
+            const char* Query = "UPDATE char_inventory SET extra = '%s' WHERE charid = %u AND location = %u AND slot = %u";
+            Sql_Query(SqlHandle, Query, extra, PChar->id, PItem->getLocationID(), PItem->getSlotID());
+        }
+    }
+
+    PChar->pushPacket(new CFurnitureInteractPacket(PItem, containerID, slotID));
+}
+
+/************************************************************************
+*                                                                       *
+*  Mog House Uproot Flowerpot
+*                                                                       *
+************************************************************************/
+
+void SmallPacket0x0FE(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
+{
+    TracyZoneScoped;
+    uint16 ItemID = data.ref<uint16>(0x04);
+    if (ItemID == 0)
+        return;
+
+    uint8 slotID = data.ref<uint8>(0x06);
+    uint8 containerID = data.ref<uint8>(0x07);
+    if (containerID != LOC_MOGSAFE && containerID != LOC_MOGSAFE2)
+        return;
+
+    CItemContainer* PItemContainer = PChar->getStorage(containerID);
+    CItemFlowerpot* PItem = (CItemFlowerpot*)PItemContainer->GetItem(slotID);
+    if (PItem == nullptr)
+        return;
+
+    uint8 isEmptyingPot = data.ref<uint8>(0x08);
+
+    if (PItem->isPlanted())
+    {
+        if (isEmptyingPot == 0 && PItem->getStage() == FLOWERPOT_STAGE_MATURE_PLANT)
+        {
+            //Harvesting plant
+            uint16 resultID;
+            uint8 totalQuantity;
+            std::tie(resultID, totalQuantity) = gardenutils::CalculateResults(PChar, PItem);
+            uint8 stackSize = itemutils::GetItemPointer(resultID)->getStackSize();
+            uint8 requiredSlots = (uint8)ceil(float(totalQuantity) / stackSize);
+            uint8 totalFreeSlots = PChar->getStorage(LOC_MOGSAFE)->GetFreeSlotsCount() + PChar->getStorage(LOC_MOGSAFE2)->GetFreeSlotsCount();
+            if (requiredSlots > totalFreeSlots || totalQuantity == 0)
+            {
+                PChar->pushPacket(new CMessageStandardPacket(MsgStd::MoghouseCantPickUp)); // Kupo... I can't pick anything right now, kupo.
+                return;
+            }
+            uint8 remainingQuantity = totalQuantity;
+            for (uint8 slot = 0; slot < requiredSlots; ++slot)
+            {
+                uint8 quantity = std::min(remainingQuantity, stackSize);
+                if (charutils::AddItem(PChar, LOC_MOGSAFE, resultID, quantity) == ERROR_SLOTID)
+                    charutils::AddItem(PChar, LOC_MOGSAFE2, resultID, quantity);
+                remainingQuantity -= quantity;
+            }
+            PChar->pushPacket(new CMessageStandardPacket(resultID, totalQuantity, 134)); // Your moogle <quantity> <item> from the plant!
+        }
+
+        PChar->pushPacket(new CFurnitureInteractPacket(PItem, containerID, slotID));
+        PItem->cleanPot();
+
+        char extra[sizeof(PItem->m_extra) * 2 + 1];
+        Sql_EscapeStringLen(SqlHandle, extra, (const char*)PItem->m_extra, sizeof(PItem->m_extra));
+        const char* Query = "UPDATE char_inventory SET extra = '%s' WHERE charid = %u AND location = %u AND slot = %u";
+        Sql_Query(SqlHandle, Query, extra, PChar->id, PItem->getLocationID(), PItem->getSlotID());
+
+        PChar->pushPacket(new CInventoryItemPacket(PItem, containerID, slotID));
+        PChar->pushPacket(new CInventoryFinishPacket());
+    }
+}
+
+/************************************************************************
+*                                                                       *
+*  Mog House Dry Flowerpot
+*                                                                       *
+************************************************************************/
+
+void SmallPacket0x0FF(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
+{
+    TracyZoneScoped;
+    uint16 itemID = data.ref<uint16>(0x04);
+    if (itemID == 0)
+        return;
+
+    uint8 slotID = data.ref<uint8>(0x06);
+    uint8 containerID = data.ref<uint8>(0x07);
+    if (containerID != LOC_MOGSAFE && containerID != LOC_MOGSAFE2)
+        return;
+
+    CItemContainer* PItemContainer = PChar->getStorage(containerID);
+    CItemFlowerpot* PItem = (CItemFlowerpot*)PItemContainer->GetItem(slotID);
+
+    if (PItem->isPlanted() && PItem->getStage() > FLOWERPOT_STAGE_INITIAL && PItem->getStage() < FLOWERPOT_STAGE_WILTED && !PItem->isDried())
+    {
+        PChar->pushPacket(new CMessageStandardPacket(itemID, 133)); // Your moogle dries the plant in the <item>.
+        PChar->pushPacket(new CFurnitureInteractPacket(PItem, containerID, slotID));
+        PItem->setDried(true);
+
+        char extra[sizeof(PItem->m_extra) * 2 + 1];
+        Sql_EscapeStringLen(SqlHandle, extra, (const char*)PItem->m_extra, sizeof(PItem->m_extra));
+        const char* Query = "UPDATE char_inventory SET extra = '%s' WHERE charid = %u AND location = %u AND slot = %u";
+        Sql_Query(SqlHandle, Query, extra, PChar->id, PItem->getLocationID(), PItem->getSlotID());
+
+        PChar->pushPacket(new CInventoryItemPacket(PItem, containerID, slotID));
+        PChar->pushPacket(new CInventoryFinishPacket());
+    }
+}
+
 /************************************************************************
 *                                                                       *
 *  Job Change                                                           *
@@ -5569,6 +5892,7 @@ void SmallPacket0x0FB(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x100(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     if (PChar->loc.zone->CanUseMisc(MISC_MOGMENU) || PChar->m_moghouseID)
     {
         uint8 mjob = data.ref<uint8>(0x04);
@@ -5672,13 +5996,14 @@ void SmallPacket0x100(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x102(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint8 job = data.ref<uint8>(0x08);
     if ((PChar->GetMJob() == JOB_BLU || PChar->GetSJob() == JOB_BLU) && job == JOB_BLU) {
         // This may be a request to add or remove set spells, so lets check.
 
         uint8 spellToAdd = data.ref<uint8>(0x04); // this is non-zero if client wants to add.
         uint8 spellInQuestion = 0;
-        uint8 spellIndex = -1;
+        int8 spellIndex = -1;
 
         if (spellToAdd == 0x00) {
             for (uint8 i = 0x0C; i <= 0x1F; i++) {
@@ -5688,10 +6013,17 @@ void SmallPacket0x102(map_session_data_t* session, CCharEntity* PChar, CBasicPac
                     CBlueSpell* spell = (CBlueSpell*)spell::GetSpell(static_cast<SpellID>(spellInQuestion + 0x200)); // the spells in this packet are offsetted by 0x200 from their spell IDs.
 
                     if (spell != nullptr) {
-                        blueutils::SetBlueSpell(PChar, spell, spellIndex, false);
+                        if (PChar->m_SetBlueSpells[spellIndex] == 0x00)
+                        {
+                            ShowExploit(CL_RED "SmallPacket0x102: Player %s trying to unset BLU spell they don't have set! \n" CL_RESET, PChar->GetName());
+                        }
+                        else
+                        {
+                            blueutils::SetBlueSpell(PChar, spell, spellIndex, false);
+                        }
                     }
                     else {
-                        ShowDebug("Cannot resolve spell id \n");
+                        ShowDebug("SmallPacket0x102: Cannot resolve spell id %u \n", spellInQuestion);
                     }
                 }
             }
@@ -5725,7 +6057,7 @@ void SmallPacket0x102(map_session_data_t* session, CCharEntity* PChar, CBasicPac
                     PChar->UpdateHealth();
                 }
                 else {
-                    ShowDebug("Cannot resolve spell id \n");
+                    ShowDebug("SmallPacket0x102: Cannot resolve spell id %u \n", spellInQuestion);
                 }
             }
             else {
@@ -5788,6 +6120,7 @@ void SmallPacket0x102(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x104(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     CCharEntity* PTarget = (CCharEntity*)PChar->GetEntity(PChar->BazaarID.targid, TYPE_PC);
 
     if (PTarget != nullptr && PTarget->id == PChar->BazaarID.id)
@@ -5813,6 +6146,7 @@ void SmallPacket0x104(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x105(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     TPZ_DEBUG_BREAK_IF(PChar->BazaarID.id != 0);
     TPZ_DEBUG_BREAK_IF(PChar->BazaarID.targid != 0);
 
@@ -5853,6 +6187,7 @@ void SmallPacket0x105(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x106(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint8 Quantity = data.ref<uint8>(0x08);
     uint8 SlotID = data.ref<uint8>(0x04);
 
@@ -5865,7 +6200,7 @@ void SmallPacket0x106(map_session_data_t* session, CCharEntity* PChar, CBasicPac
     if (Quantity < 1)
     {
         // Exploit attempt..
-        ShowError(
+        ShowExploit(
             CL_RED "Player %s purchasing invalid quantity %u from Player %s bazaar! \n" CL_RESET,
             PChar->GetName(), Quantity, PTarget->GetName());
         return;
@@ -5902,7 +6237,7 @@ void SmallPacket0x106(map_session_data_t* session, CCharEntity* PChar, CBasicPac
         if (PCharGil->getQuantity() < PriceWithTax)
         {
             // Exploit attempt
-            ShowError(CL_RED "Bazaar purchase exploit attempt by: %s\n" CL_RESET, PChar->GetName());
+            ShowExploit(CL_RED "Bazaar purchase exploit attempt by: %s\n" CL_RESET, PChar->GetName());
             PChar->pushPacket(new CBazaarPurchasePacket(PTarget, false));
             return;
         }
@@ -5977,6 +6312,7 @@ void SmallPacket0x106(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x109(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     CItemContainer* PStorage = PChar->getStorage(LOC_INVENTORY);
 
     for (uint8 slotID = 1; slotID <= PStorage->GetSize(); ++slotID)
@@ -6001,6 +6337,7 @@ void SmallPacket0x109(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x10A(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     uint8  slotID = data.ref<uint8>(0x04);
     uint32 price = data.ref<uint32>(0x08);
 
@@ -6033,6 +6370,7 @@ void SmallPacket0x10A(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x10B(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     for (uint16 i = 0; i < PChar->BazaarCustomers.size(); ++i)
     {
         CCharEntity* PCustomer = (CCharEntity*)PChar->GetEntity(PChar->BazaarCustomers[i].targid, TYPE_PC);
@@ -6049,6 +6387,40 @@ void SmallPacket0x10B(map_session_data_t* session, CCharEntity* PChar, CBasicPac
     return;
 }
 
+/************************************************************************
+*                                                                        *
+*  Eminence Record Start                                                  *
+*                                                                        *
+************************************************************************/
+
+void SmallPacket0x10C(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
+{
+    TracyZoneScoped;
+    if (roeutils::RoeSystem.RoeEnabled)
+    {
+        roeutils::AddEminenceRecord(PChar, data.ref<uint32>(0x04));
+        PChar->pushPacket(new CRoeSparkUpdatePacket(PChar));
+    }
+    return;
+}
+
+/************************************************************************
+*                                                                        *
+*  Eminence Record Drop                                                  *
+*                                                                        *
+************************************************************************/
+
+void SmallPacket0x10D(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
+{
+    TracyZoneScoped;
+    if (roeutils::RoeSystem.RoeEnabled)
+    {
+        roeutils::DelEminenceRecord(PChar, data.ref<uint32>(0x04));
+        PChar->pushPacket(new CRoeSparkUpdatePacket(PChar));
+    }
+    return;
+}
+
 /************************************************************************
 *                                                                        *
 *  Request Currency1 tab                                                  *
@@ -6057,6 +6429,7 @@ void SmallPacket0x10B(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x10F(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     PChar->pushPacket(new CCurrencyPacket1(PChar));
     return;
 }
@@ -6069,6 +6442,7 @@ void SmallPacket0x10F(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x110(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     //PrintPacket(data);
     if (PChar->animation != ANIMATION_FISHING_START)
         return;
@@ -6093,18 +6467,54 @@ void SmallPacket0x110(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x111(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     charutils::SetStyleLock(PChar, data.ref<uint8>(0x04));
     PChar->pushPacket(new CCharAppearancePacket(PChar));
     return;
 }
 
+/************************************************************************
+*                                                                        *
+*  Roe Quest Log Request                                                 *
+*                                                                        *
+************************************************************************/
+
+void SmallPacket0x112(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
+{
+    TracyZoneScoped;
+    // Send spark updates
+    PChar->pushPacket(new CRoeSparkUpdatePacket(PChar));
+
+    if (roeutils::RoeSystem.RoeEnabled)
+    {
+        // Current RoE quests
+        PChar->pushPacket(new CRoeUpdatePacket(PChar));
+
+        // Players logging in to a new timed record get one-time message
+        if (PChar->m_eminenceCache.notifyTimedRecord)
+        {
+            PChar->m_eminenceCache.notifyTimedRecord = false;
+            PChar->pushPacket(new CMessageBasicPacket(PChar, PChar, roeutils::GetActiveTimedRecord(), 0, MSGBASIC_ROE_TIMED));
+        }
+
+        // 4-part Eminence Completion bitmap
+        for (int i = 0; i < 4; i++)
+        {
+            PChar->pushPacket(new CRoeQuestLogPacket(PChar, i));
+        }
+    }
+
+    return;
+}
+
 /************************************************************************
 *                                                                       *
 *  /sitchair                                                            *
 *                                                                       *
 ************************************************************************/
 void SmallPacket0x113(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     PrintPacket(data);
 
     if (PChar->status != STATUS_NORMAL)
@@ -6144,6 +6554,7 @@ void SmallPacket0x113(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x114(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     PChar->pushPacket(new CMapMarkerPacket(PChar));
 }
 
@@ -6155,10 +6566,25 @@ void SmallPacket0x114(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void SmallPacket0x115(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
 {
+    TracyZoneScoped;
     PChar->pushPacket(new CCurrencyPacket2(PChar));
     return;
 }
 
+/************************************************************************
+*                                                                        *
+*  Unity Menu Packet (Possibly incomplete)                               *
+*  This stub only handles the needed RoE updates.                        *
+*                                                                        *
+************************************************************************/
+
+void SmallPacket0x117(map_session_data_t* session, CCharEntity* PChar, CBasicPacket data)
+{
+    TracyZoneScoped;
+    PChar->pushPacket(new CRoeSparkUpdatePacket(PChar));
+    return;
+}
+
 /************************************************************************
 *                                                                       *
 *  Packet Array Initialization                                          *
@@ -6167,11 +6593,13 @@ void SmallPacket0x115(map_session_data_t* session, CCharEntity* PChar, CBasicPac
 
 void PacketParserInitialize()
 {
+    TracyZoneScoped;
     for (uint16 i = 0; i < 512; ++i)
     {
         PacketSize[i] = 0;
         PacketParser[i] = &SmallPacket0x000;
     }
+    // clang-format off
     PacketSize[0x00A] = 0x2E; PacketParser[0x00A] = &SmallPacket0x00A;
     PacketSize[0x00C] = 0x00; PacketParser[0x00C] = &SmallPacket0x00C;
     PacketSize[0x00D] = 0x04; PacketParser[0x00D] = &SmallPacket0x00D;
@@ -6260,6 +6688,9 @@ void PacketParserInitialize()
     PacketSize[0x0F6] = 0x00; PacketParser[0x0F6] = &SmallPacket0x0F6;
     PacketSize[0x0FA] = 0x00; PacketParser[0x0FA] = &SmallPacket0x0FA;
     PacketSize[0x0FB] = 0x00; PacketParser[0x0FB] = &SmallPacket0x0FB;
+    PacketSize[0x0FC] = 0x00; PacketParser[0x0FC] = &SmallPacket0x0FC;
+    PacketSize[0x0FD] = 0x00; PacketParser[0x0FD] = &SmallPacket0x0FD;
+    PacketSize[0x0FE] = 0x00; PacketParser[0x0FE] = &SmallPacket0x0FE;
     PacketSize[0x100] = 0x04; PacketParser[0x100] = &SmallPacket0x100;
     PacketSize[0x102] = 0x52; PacketParser[0x102] = &SmallPacket0x102;
     PacketSize[0x104] = 0x02; PacketParser[0x104] = &SmallPacket0x104;
@@ -6268,13 +6699,18 @@ void PacketParserInitialize()
     PacketSize[0x109] = 0x00; PacketParser[0x109] = &SmallPacket0x109;
     PacketSize[0x10A] = 0x06; PacketParser[0x10A] = &SmallPacket0x10A;
     PacketSize[0x10B] = 0x00; PacketParser[0x10B] = &SmallPacket0x10B;
+    PacketSize[0x10C] = 0x04; PacketParser[0x10C] = &SmallPacket0x10C;
+    PacketSize[0x10D] = 0x04; PacketParser[0x10D] = &SmallPacket0x10D;
     PacketSize[0x10F] = 0x02; PacketParser[0x10F] = &SmallPacket0x10F;
     PacketSize[0x110] = 0x0A; PacketParser[0x110] = &SmallPacket0x110;
     PacketSize[0x111] = 0x00; PacketParser[0x111] = &SmallPacket0x111; // Lock Style Request
-    PacketSize[0x112] = 0x00; PacketParser[0x112] = &SmallPacket0xFFF;
+    PacketSize[0x112] = 0x00; PacketParser[0x112] = &SmallPacket0x112;
     PacketSize[0x113] = 0x06; PacketParser[0x113] = &SmallPacket0x113;
     PacketSize[0x114] = 0x00; PacketParser[0x114] = &SmallPacket0x114;
     PacketSize[0x115] = 0x02; PacketParser[0x115] = &SmallPacket0x115;
+    PacketSize[0x116] = 0x02; PacketParser[0x116] = &SmallPacket0xFFF; // not implemented
+    PacketSize[0x117] = 0x00; PacketParser[0x117] = &SmallPacket0x117;
+    // clang-format on
 }
 
 /************************************************************************