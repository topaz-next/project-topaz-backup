@@ -463,7 +463,7 @@ namespace battleutils
                 PAttacker->delModifier(Mod::ENSPELL_DMG, 1);
             else
             {
-                if (element == 7)
+                if (element == ELEMENT_DARK)
                     PAttacker->StatusEffectContainer->DelStatusEffect(EFFECT_ENDARK);
                 else
                     PAttacker->StatusEffectContainer->DelStatusEffect(EFFECT_ENLIGHT);
@@ -478,14 +478,14 @@ namespace battleutils
         uint32 WeekDay = CVanaTime::getInstance()->getWeekday();
         WEATHER weather = GetWeather(PAttacker, false);
 
-        DAYTYPE strongDay[8] = { FIRESDAY, EARTHSDAY, WATERSDAY, WINDSDAY, ICEDAY, LIGHTNINGDAY, LIGHTSDAY, DARKSDAY };
-        DAYTYPE weakDay[8] = { WATERSDAY, WINDSDAY, LIGHTNINGDAY, ICEDAY, FIRESDAY, EARTHSDAY, DARKSDAY, LIGHTSDAY };
-        WEATHER strongWeatherSingle[8] = { WEATHER_HOT_SPELL, WEATHER_DUST_STORM, WEATHER_RAIN, WEATHER_WIND, WEATHER_SNOW, WEATHER_THUNDER, WEATHER_AURORAS, WEATHER_GLOOM };
-        WEATHER strongWeatherDouble[8] = { WEATHER_HEAT_WAVE, WEATHER_SAND_STORM, WEATHER_SQUALL, WEATHER_GALES, WEATHER_BLIZZARDS, WEATHER_THUNDERSTORMS, WEATHER_STELLAR_GLARE, WEATHER_DARKNESS };
-        WEATHER weakWeatherSingle[8] = { WEATHER_RAIN, WEATHER_WIND, WEATHER_THUNDER, WEATHER_SNOW, WEATHER_HOT_SPELL, WEATHER_DUST_STORM, WEATHER_GLOOM, WEATHER_AURORAS };
-        WEATHER weakWeatherDouble[8] = { WEATHER_SQUALL, WEATHER_GALES, WEATHER_THUNDERSTORMS, WEATHER_BLIZZARDS, WEATHER_HEAT_WAVE, WEATHER_SAND_STORM, WEATHER_DARKNESS, WEATHER_STELLAR_GLARE };
-        uint32 obi[8] = { 15435, 15438, 15440, 15437, 15436, 15439, 15441, 15442 };
-        Mod resistarray[8] = { Mod::FIRERES, Mod::EARTHRES, Mod::WATERRES, Mod::WINDRES, Mod::ICERES, Mod::THUNDERRES, Mod::LIGHTRES, Mod::DARKRES };
+        DAYTYPE strongDay[8] = { FIRESDAY, ICEDAY, WINDSDAY, EARTHSDAY, LIGHTNINGDAY, WATERSDAY, LIGHTSDAY, DARKSDAY };
+        DAYTYPE weakDay[8] = { WATERSDAY, FIRESDAY, ICEDAY, WINDSDAY, EARTHSDAY, LIGHTNINGDAY, DARKSDAY, LIGHTSDAY };
+        WEATHER strongWeatherSingle[8] = { WEATHER_HOT_SPELL, WEATHER_SNOW, WEATHER_WIND, WEATHER_DUST_STORM, WEATHER_THUNDER, WEATHER_RAIN, WEATHER_AURORAS, WEATHER_GLOOM };
+        WEATHER strongWeatherDouble[8] = { WEATHER_HEAT_WAVE, WEATHER_BLIZZARDS, WEATHER_GALES, WEATHER_SAND_STORM, WEATHER_THUNDERSTORMS, WEATHER_SQUALL, WEATHER_STELLAR_GLARE, WEATHER_DARKNESS };
+        WEATHER weakWeatherSingle[8] = { WEATHER_HOT_SPELL, WEATHER_SNOW, WEATHER_WIND, WEATHER_DUST_STORM, WEATHER_THUNDER, WEATHER_RAIN, WEATHER_GLOOM, WEATHER_AURORAS };
+        WEATHER weakWeatherDouble[8] = { WEATHER_SQUALL, WEATHER_HEAT_WAVE, WEATHER_BLIZZARDS, WEATHER_GALES, WEATHER_SAND_STORM, WEATHER_THUNDERSTORMS, WEATHER_DARKNESS, WEATHER_STELLAR_GLARE };
+        uint32 obi[8] = { 15435, 15436, 15437, 15438, 15439, 15440, 15441, 15442 };
+        Mod resistarray[8] = { Mod::FIRERES, Mod::ICERES, Mod::WINDRES, Mod::EARTHRES, Mod::THUNDERRES, Mod::WATERRES, Mod::LIGHTRES, Mod::DARKRES };
         bool obiBonus = false;
 
         double half = (double)(PDefender->getMod(resistarray[element])) / 100;
@@ -578,7 +578,7 @@ namespace battleutils
         // Handle Retaliation
         if (PDefender->StatusEffectContainer->HasStatusEffect(EFFECT_RETALIATION) && PDefender->PAI->IsEngaged()
             && battleutils::GetHitRate(PDefender, PAttacker) / 2 > tpzrand::GetRandomNumber(100)
-            && isFaceing(PDefender->loc.p, PAttacker->loc.p, 40))
+            && facing(PDefender->loc.p, PAttacker->loc.p, 64))
         {
             // Retaliation rate is based on player acc vs mob evasion. Missed retaliations do not even display in log.
             // Other theories exist but were not proven or reliably tested (I have to assume too many things to even consider JP translations about weapon delay), this at least has data to back it up.
@@ -889,53 +889,13 @@ namespace battleutils
         if (PAttacker->getMod(Mod::ENSPELL) > 0 && (PAttacker->getMod(Mod::ENSPELL_CHANCE) == 0 ||
             PAttacker->getMod(Mod::ENSPELL_CHANCE) > tpzrand::GetRandomNumber(100)))
         {
-            SUBEFFECT subeffects[8] = { SUBEFFECT_LIGHT_DAMAGE, SUBEFFECT_DARKNESS_DAMAGE, SUBEFFECT_FIRE_DAMAGE, SUBEFFECT_EARTH_DAMAGE,
-                SUBEFFECT_WATER_DAMAGE, SUBEFFECT_WIND_DAMAGE, SUBEFFECT_ICE_DAMAGE, SUBEFFECT_LIGHTNING_DAMAGE };
-            int16 enspell = PAttacker->getMod(Mod::ENSPELL);
-
-            if (enspell > 0 && enspell <= 6)
+            static SUBEFFECT enspell_subeffects[8] =
             {
-                Action->additionalEffect = subeffects[enspell + 1];
-                Action->addEffectMessage = 163;
-                Action->addEffectParam = CalculateEnspellDamage(PAttacker, PDefender, 1, enspell - 1);
-
-                if (Action->addEffectParam < 0)
-                {
-                    Action->addEffectParam = -Action->addEffectParam;
-                    Action->addEffectMessage = 384;
-                }
-
-                PDefender->takeDamage(Action->addEffectParam, PAttacker, ATTACK_MAGICAL, GetEnspellDamageType((ENSPELL)enspell));
-            }
-            else if (enspell > 8 && enspell <= 14 && isFirstSwing)
-            {
-                Action->additionalEffect = subeffects[enspell - 7];
-                Action->addEffectMessage = 163;
-                Action->addEffectParam = CalculateEnspellDamage(PAttacker, PDefender, 2, enspell - 9);
-
-                if (Action->addEffectParam < 0)
-                {
-                    Action->addEffectParam = -Action->addEffectParam;
-                    Action->addEffectMessage = 384;
-                }
-
-                PDefender->takeDamage(Action->addEffectParam, PAttacker, ATTACK_MAGICAL, GetEnspellDamageType((ENSPELL)enspell));
-            }
-            else if (enspell > 6 && enspell <= 8)
-            {
-                Action->additionalEffect = subeffects[enspell - 7];
-                Action->addEffectMessage = 163;
-                Action->addEffectParam = CalculateEnspellDamage(PAttacker, PDefender, 3, enspell - 1);
-
-                if (Action->addEffectParam < 0)
-                {
-                    Action->addEffectParam = -Action->addEffectParam;
-                    Action->addEffectMessage = 384;
-                }
-
-                PDefender->takeDamage(Action->addEffectParam, PAttacker, ATTACK_MAGICAL, GetEnspellDamageType((ENSPELL)enspell));
-            }
-            else if (enspell == ENSPELL_BLOOD_WEAPON)
+                SUBEFFECT_FIRE_DAMAGE, SUBEFFECT_ICE_DAMAGE, SUBEFFECT_WIND_DAMAGE, SUBEFFECT_EARTH_DAMAGE,
+                SUBEFFECT_LIGHTNING_DAMAGE, SUBEFFECT_WATER_DAMAGE, SUBEFFECT_LIGHT_DAMAGE, SUBEFFECT_DARKNESS_DAMAGE,
+            };
+            uint8 enspell = (uint8) PAttacker->getMod(Mod::ENSPELL);
+            if (enspell == ENSPELL_BLOOD_WEAPON)
             {
                 Action->additionalEffect = SUBEFFECT_HP_DRAIN;
                 Action->addEffectMessage = 161;
@@ -959,6 +919,43 @@ namespace battleutils
 
                 PDefender->takeDamage(Action->addEffectParam, PAttacker, ATTACK_MAGICAL, GetEnspellDamageType((ENSPELL)enspell));
             }
+            else if (enspell <= ENSPELL_II_DARK) // Elemental enspells
+            {
+                if (enspell > ENSPELL_I_DARK && isFirstSwing ) // Tier II elemental enspell
+                {
+                    //Enlight II and Endark II currently not implemented; may vary
+                    Action->additionalEffect = enspell_subeffects[enspell - 9];
+                    Action->addEffectParam = CalculateEnspellDamage(PAttacker, PDefender, 2, enspell - 8);
+                }
+                else if (enspell <= ENSPELL_I_DARK) // Tier I elemental enspell
+                {
+                    Action->additionalEffect = enspell_subeffects[enspell - 1];
+                    if (enspell >= ENSPELL_I_LIGHT) // Enlight or Endark
+                    {
+                        Action->addEffectParam = CalculateEnspellDamage(PAttacker, PDefender, 3, enspell);
+                    }
+                    else
+                    {
+                        Action->addEffectParam = CalculateEnspellDamage(PAttacker, PDefender, 1, enspell);
+                    }
+
+                }
+
+                if (Action->additionalEffect)
+                {
+                    if (Action->addEffectParam < 0)
+                    {
+                        Action->addEffectParam = -Action->addEffectParam;
+                        Action->addEffectMessage = 384;
+                    }
+                    else
+                    {
+                        Action->addEffectMessage = 163;
+                    }
+
+                    PDefender->takeDamage(Action->addEffectParam, PAttacker, ATTACK_MAGICAL, GetEnspellDamageType((ENSPELL)enspell));
+                }
+            }
         }
         //check weapon for additional effects
         else if (PAttacker->objtype == TYPE_PC && battleutils::GetScaledItemModifier(PAttacker, weapon, Mod::ITEM_ADDEFFECT_TYPE) > 0 &&
@@ -1376,7 +1373,7 @@ namespace battleutils
             }
 
             //Check For Ambush Merit - Ranged
-            if ((charutils::hasTrait((CCharEntity*)PAttacker, TRAIT_AMBUSH)) && ((abs(PDefender->loc.p.rotation - PAttacker->loc.p.rotation) < 23))) {
+            if ((charutils::hasTrait((CCharEntity*)PAttacker, TRAIT_AMBUSH)) && behind(PAttacker->loc.p, PDefender->loc.p, 64)) {
                 acc += ((CCharEntity*)PAttacker)->PMeritPoints->GetMeritValue(MERIT_AMBUSH, (CCharEntity*)PAttacker);
             }
 
@@ -1386,7 +1383,7 @@ namespace battleutils
             acc = PAttacker->RACC(SKILL_AUTOMATON_RANGED);
         }
         // Check for Yonin evasion bonus while in front of target
-        if (PDefender->StatusEffectContainer->HasStatusEffect(EFFECT_YONIN) && ((abs(abs(PAttacker->loc.p.rotation - PDefender->loc.p.rotation) - 128) < 23)))
+        if (PDefender->StatusEffectContainer->HasStatusEffect(EFFECT_YONIN) && infront(PDefender->loc.p, PAttacker->loc.p, 64))
         {
             acc -= PDefender->StatusEffectContainer->GetStatusEffect(EFFECT_YONIN)->GetPower();
         }
@@ -1753,7 +1750,8 @@ namespace battleutils
         if (validWeapon && hasGuardSkillRank && PDefender->PAI->IsEngaged())
         {
             // assuming this is like parry
-            float skill = (float)PDefender->GetSkill(SKILL_GUARD) + PDefender->getMod(Mod::GUARD);
+            float gbase = (float)PDefender->GetSkill(SKILL_GUARD) + PDefender->getMod(Mod::GUARD);
+            float skill = (float)gbase + ((float)gbase * (PDefender->getMod(Mod::GUARD_PERCENT) / 100));
 
             if (PWeapon)
                 skill += PWeapon->getILvlParry(); //no weapon will ever have ilvl guard and parry
@@ -2000,7 +1998,9 @@ namespace battleutils
             if (giveTPtoVictim)
             {
                 //account for attacker's subtle blow which reduces the baseTP gain for the defender
-                float sBlowMult = ((100.0f - std::clamp((float)PAttacker->getMod(Mod::SUBTLE_BLOW), 0.0f, 50.0f)) / 100.0f);
+                float sBlow1 = std::clamp((float)PAttacker->getMod(Mod::SUBTLE_BLOW), -50.0f, 50.0f);
+                float sBlow2 = std::clamp((float)PAttacker->getMod(Mod::SUBTLE_BLOW_II), -50.0f, 50.0f);
+                float sBlowMult = ((100.0f - std::clamp((float)(sBlow1 + sBlow2), -75.0f, 75.0f)) / 100.0f);
 
                 //mobs hit get basetp+30 whereas pcs hit get basetp/3
                 if (PDefender->objtype == TYPE_PC || (PDefender->objtype == TYPE_PET && PDefender->PMaster && PDefender->PMaster->objtype == TYPE_PC))
@@ -2126,7 +2126,9 @@ namespace battleutils
             }
 
             //account for attacker's subtle blow which reduces the baseTP gain for the defender
-            float sBlowMult = ((100.0f - std::clamp((float)PAttacker->getMod(Mod::SUBTLE_BLOW), 0.0f, 50.0f)) / 100.0f);
+            float sBlow1 = std::clamp((float)PAttacker->getMod(Mod::SUBTLE_BLOW), -50.0f, 50.0f);
+            float sBlow2 = std::clamp((float)PAttacker->getMod(Mod::SUBTLE_BLOW_II), -50.0f, 50.0f);
+            float sBlowMult = ((100.0f - std::clamp((float)(sBlow1 + sBlow2), -75.0f, 75.0f)) / 100.0f);
 
             //mobs hit get basetp+30 whereas pcs hit get basetp/3
             if (PDefender->objtype == TYPE_PC)
@@ -2180,7 +2182,7 @@ namespace battleutils
 
     /************************************************************************
     *                                                                       *
-    *  Calculate Probability attack will hit (20% min cap - 95% max cap)    *
+    *  Calculate Probability attack will hit (20% min cap - 95~99% max cap) *
     *  attackNumber: 0=main, 1=sub, 2=kick                                  *
     *                                                                       *
     ************************************************************************/
@@ -2189,51 +2191,122 @@ namespace battleutils
     {
         int32 hitrate = 75;
 
-        if (PAttacker->objtype == TYPE_PC && ((PAttacker->StatusEffectContainer->HasStatusEffect(EFFECT_SNEAK_ATTACK) && (abs(PDefender->loc.p.rotation - PAttacker->loc.p.rotation) < 23 || PAttacker->StatusEffectContainer->HasStatusEffect(EFFECT_HIDE))) ||
+        if (PAttacker->objtype == TYPE_PC && ((PAttacker->StatusEffectContainer->HasStatusEffect(EFFECT_SNEAK_ATTACK) && (behind(PAttacker->loc.p, PDefender->loc.p, 64) || PAttacker->StatusEffectContainer->HasStatusEffect(EFFECT_HIDE))) ||
             (charutils::hasTrait((CCharEntity*)PAttacker, TRAIT_ASSASSIN) && PAttacker->StatusEffectContainer->HasStatusEffect(EFFECT_TRICK_ATTACK) && battleutils::getAvailableTrickAttackChar(PAttacker, PDefender))))
         {
-            hitrate = 100; //attack with SA active or TA/Assassin cannot miss
+            hitrate = 100; // Attack with SA active or TA/Assassin cannot miss
         }
         else
         {
-            //ShowDebug("Accuracy mod before direction checks: %d\n", offsetAccuracy);
-            //Check For Ambush Merit - Melee
-            if (PAttacker->objtype == TYPE_PC && (charutils::hasTrait((CCharEntity*)PAttacker, TRAIT_AMBUSH)) && ((abs(PDefender->loc.p.rotation - PAttacker->loc.p.rotation) < 23)))
+            // ShowDebug("Accuracy mod before direction checks: %d\n", offsetAccuracy);
+            // Check For Ambush Merit - Melee
+            if (PAttacker->objtype == TYPE_PC && (charutils::hasTrait((CCharEntity*)PAttacker, TRAIT_AMBUSH)) && behind(PAttacker->loc.p, PDefender->loc.p, 64))
             {
                 offsetAccuracy += ((CCharEntity*)PAttacker)->PMeritPoints->GetMeritValue(MERIT_AMBUSH, (CCharEntity*)PAttacker);
             }
-            // Check for Closed Position merit on attacker and that attacker and defender are facing each other (within ~20 degrees from straight on)
-            if (PAttacker->objtype == TYPE_PC && (charutils::hasTrait((CCharEntity*)PAttacker, TRAIT_CLOSED_POSITION)) && ((abs(abs(PDefender->loc.p.rotation - PAttacker->loc.p.rotation) - 128) < 15)))
+            // Check for Closed Position merit on attacker for additional accuracy and that attacker and defender are facing each other
+            if (PAttacker->objtype == TYPE_PC && (charutils::hasTrait((CCharEntity*)PAttacker, TRAIT_CLOSED_POSITION)) && (infront(PAttacker->loc.p, PDefender->loc.p, 64) && facing(PAttacker->loc.p, PDefender->loc.p, 64)))
             {
                 offsetAccuracy += ((CCharEntity*)PAttacker)->PMeritPoints->GetMeritValue(MERIT_CLOSED_POSITION, (CCharEntity*)PAttacker);
             }
-            // Check for Closed Position merit on defender that attacker and defender are facing each other (within ~20 degrees from straight on)
-            if (PDefender->objtype == TYPE_PC && (charutils::hasTrait((CCharEntity*)PDefender, TRAIT_CLOSED_POSITION)) && ((abs(abs(PDefender->loc.p.rotation - PAttacker->loc.p.rotation) - 128) < 15)))
+            // Check for Closed Position merit on defender for additional evasion and that attacker and defender are facing each other
+            if (PDefender->objtype == TYPE_PC && (charutils::hasTrait((CCharEntity*)PDefender, TRAIT_CLOSED_POSITION)) && (infront(PDefender->loc.p, PAttacker->loc.p, 64) && facing(PDefender->loc.p, PAttacker->loc.p, 64)))
             {
                 offsetAccuracy -= ((CCharEntity*)PDefender)->PMeritPoints->GetMeritValue(MERIT_CLOSED_POSITION, (CCharEntity*)PDefender);
             }
             // Check for Innin accuracy bonus from behind target
-            if (PAttacker->StatusEffectContainer->HasStatusEffect(EFFECT_INNIN) && ((abs(PDefender->loc.p.rotation - PAttacker->loc.p.rotation) < 23)))
+            if (PAttacker->StatusEffectContainer->HasStatusEffect(EFFECT_INNIN) && behind(PAttacker->loc.p, PDefender->loc.p, 64))
             {
                 offsetAccuracy += PAttacker->StatusEffectContainer->GetStatusEffect(EFFECT_INNIN)->GetPower();
             }
             // Check for Yonin evasion bonus while in front of target
-            if (PDefender->StatusEffectContainer->HasStatusEffect(EFFECT_YONIN) && ((abs(abs(PAttacker->loc.p.rotation - PDefender->loc.p.rotation) - 128) < 23)))
+            if (PDefender->StatusEffectContainer->HasStatusEffect(EFFECT_YONIN) && infront(PDefender->loc.p, PAttacker->loc.p, 64))
             {
                 offsetAccuracy -= PDefender->StatusEffectContainer->GetStatusEffect(EFFECT_YONIN)->GetPower();
             }
-            //ShowDebug("Accuracy mod after direction checks: %d\n", offsetAccuracy);
+            // ShowDebug("Accuracy mod after direction checks: %d\n", offsetAccuracy);
 
-            hitrate = hitrate + (PAttacker->ACC(attackNumber, offsetAccuracy) - PDefender->EVA()) / 2 + (PAttacker->GetMLevel() - PDefender->GetMLevel()) * 2;
 
+            // Hit Rate (%) = 75 + floor( (Accuracy - Evasion)/2 ) + 2*(dLVL)
+            // For Avatars negative penalties for level correction seem to be ignored for attack and likely for accuracy,
+            // bonuses cap at level diff of 38 based on this testing: 
+            // https://www.bluegartr.com/threads/114636-Monster-Avatar-Pet-damage
+
+            // Floor because hitrate can only be integer values
+            // https://www.bluegartr.com/threads/68786-Dexterity-s-impact-on-critical-hits?p=3209015&viewfull=1#post3209015
+
+            uint16 attackerAcc = PAttacker->ACC(attackNumber, offsetAccuracy);
+
+            // Enlight gives an ACC bonus not a hit rate bonus, ACC bonus is equal to damage dealt
             if (PAttacker->StatusEffectContainer->HasStatusEffect(EFFECT_ENLIGHT))
             {
-                hitrate += PAttacker->getMod(Mod::ENSPELL_DMG);
+                attackerAcc += PAttacker->getMod(Mod::ENSPELL_DMG);
             }
 
-            hitrate = std::clamp(hitrate, 20, 95);
+            hitrate += static_cast<int32>(std::floor((attackerAcc - PDefender->EVA()) / 2));
+
+            // Level correction does not happen in Adoulin zones, Legion, or zones in Escha/Reisenjima
+            // https://www.bg-wiki.com/bg/PDIF#Level_Correction_Function_.28cRatio.29
+            uint16 zoneId = PAttacker->getZone();
+            
+            // All zones from Adoulin onward have an id of 256+
+            // This includes Escha/Reisenjima and the new Dynamis zones
+            // (Not a post Adoulin Zone) && (Not Legion_A)
+            bool shouldApplyLevelCorrection = (zoneId < 256) && (zoneId != 183);
+
+            if (shouldApplyLevelCorrection) {
+                uint8 dLvl = PAttacker->GetMLevel() - PDefender->GetMLevel();
+                // Skip penalties for avatars, this should likely be all pets and mobs but I have no proof
+                // of this for ACC, ATT level correction for Pets/Avatars is the same as mobs though.
+                bool isPet = PAttacker->objtype == TYPE_PET;
+                bool isAvatar = false;
+                
+                if (isPet) {
+                    CPetEntity* petEntity = dynamic_cast<CPetEntity*>(PAttacker);
+                    isAvatar = petEntity->getPetType() == PETTYPE_AVATAR;
+                }
+
+                if (isAvatar)
+                {
+                    if (dLvl > 0)
+                    {
+                        // Avatars have a known level difference cap of 38
+                        hitrate += static_cast<int16>(std::min(dLvl, (uint8)38) * 2);
+                    }
+                }
+                else
+                {
+                    // Everything else has no known caps, though it's likely 38 like avatars
+                    hitrate += static_cast<int16>(dLvl * 2);
+                }
+            }
+
+            // https://www.bg-wiki.com/bg/Hit_Rate
+            // Update Notes: https://forum.square-enix.com/ffxi/threads/45365?p=534537#post534537
+            // The maximum accuracy of one-handed weapons equipped as the main weapon has been increased from 95% to 99%.
+            // * Owing to this change, the maximum accuracy of abilities that rely on main weapon accuracy has also been raised from 95% to 99%.
+            // Further, some monster damage types have been changed from hand-to-hand to blunt.* Fellows and alter egos enjoy this benefit as well.
+            // The maximum accuracy of beastmaster familiars, wyverns, avatars, and automatons has been increased from 95% to 99%.
+            // * In line with this change, familiars summoned using the following items have had their damage types changed from hand-to-hand to blunt.
+            // Carrot Broth / Famous Carrot Broth / Bug Broth / Quadav Bug Broth / Berbal Broth / Singing Herbal Broth / Carrion Broth / 
+            // Cold Carrion Broth / Meat Broth / Warm Meat Broth / Tree Sap / Scarlet Sap / Fish Broth / Fish Oil Broth / Seedbed Soil / Sun Water / 
+            // Grasshopper Broth / Noisy Grasshopper Broth / Mole Broth / Lively Mole Broth / Blood Broth / Clear Blood Broth / Antica Broth / Fragrant Antica Broth
+
+            int32 maxHitRate = 99;
+            auto targ_weapon = dynamic_cast<CItemWeapon*>(PAttacker->m_Weapons[SLOT_MAIN]);
+
+            // As far as I can tell kick attacks fall under Hand-to-Hand so ignoring them and letting them go to 99
+            bool isOffhand = attackNumber == 1;
+            bool isTwoHanded = targ_weapon && targ_weapon->isTwoHanded();
+
+            if (isOffhand || isTwoHanded)
+            {
+                maxHitRate = 95;
+            }
+
+            hitrate = std::clamp(hitrate, 20, maxHitRate);
         }
-        return (uint8)hitrate;
+        return static_cast<uint8>(hitrate);
     }
     uint8 GetHitRate(CBattleEntity* PAttacker, CBattleEntity* PDefender)
     {
@@ -2263,8 +2336,7 @@ namespace battleutils
         }
         else if (PAttacker->objtype == TYPE_PC && (!ignoreSneakTrickAttack) && PAttacker->StatusEffectContainer->HasStatusEffect(EFFECT_SNEAK_ATTACK))
         {
-
-            if (abs(PDefender->loc.p.rotation - PAttacker->loc.p.rotation) < 23 || PAttacker->StatusEffectContainer->HasStatusEffect(EFFECT_HIDE))
+            if (behind(PAttacker->loc.p, PDefender->loc.p, 64) || PAttacker->StatusEffectContainer->HasStatusEffect(EFFECT_HIDE))
             {
                 crithitrate = 100;
             }
@@ -2277,7 +2349,7 @@ namespace battleutils
         }
         else
         {
-            //apply merit mods and traits
+            // apply merit mods and traits
             if (PAttacker->objtype == TYPE_PC)
             {
                 CCharEntity* PCharAttacker = static_cast<CCharEntity*>(PAttacker);
@@ -2293,31 +2365,79 @@ namespace battleutils
                 }
             }
 
-            if (PDefender->objtype == TYPE_PC) crithitrate -= ((CCharEntity*)PDefender)->PMeritPoints->GetMeritValue(MERIT_ENEMY_CRIT_RATE, (CCharEntity*)PDefender);
-            //ShowDebug("Crit rate mod before Innin/Yonin: %d\n", crithitrate);
+            // ShowDebug("Crit rate mod before Innin/Yonin: %d\n", crithitrate);
+            if (PDefender->objtype == TYPE_PC)
+            {
+                crithitrate -= ((CCharEntity*)PDefender)->PMeritPoints->GetMeritValue(MERIT_ENEMY_CRIT_RATE, (CCharEntity*)PDefender);
+            }
+
             // Check for Innin crit rate bonus from behind target
-            if (PAttacker->StatusEffectContainer->HasStatusEffect(EFFECT_INNIN) && ((abs(PDefender->loc.p.rotation - PAttacker->loc.p.rotation) < 23)))
+            if (PAttacker->StatusEffectContainer->HasStatusEffect(EFFECT_INNIN) && behind(PAttacker->loc.p, PDefender->loc.p, 64))
             {
                 crithitrate += PAttacker->StatusEffectContainer->GetStatusEffect(EFFECT_INNIN)->GetPower();
             }
-            // Check for Yonin crit rate bonus while in front of target
-            if (PDefender->StatusEffectContainer->HasStatusEffect(EFFECT_YONIN) && ((abs(abs(PAttacker->loc.p.rotation - PDefender->loc.p.rotation) - 128) < 23)))
+            // Check for Yonin enemy crit rate reduction while in front of target
+            if (PDefender->StatusEffectContainer->HasStatusEffect(EFFECT_YONIN) && infront(PDefender->loc.p, PAttacker->loc.p, 64))
             {
                 crithitrate -= PDefender->StatusEffectContainer->GetStatusEffect(EFFECT_YONIN)->GetPower();
             }
-            //ShowDebug("Crit rate mod after Innin/Yonin: %d\n", crithitrate);
 
-            int32 attackerdex = PAttacker->DEX();
-            int32 defenderagi = PDefender->AGI();
+            // ShowDebug("Crit rate mod after Innin/Yonin: %d\n", crithitrate);
 
-            int32 dDEX = std::clamp(attackerdex - defenderagi, 0, 50);
-
-            crithitrate += (dDEX * 30) / 100 + PAttacker->getMod(Mod::CRITHITRATE) + PDefender->getMod(Mod::ENEMYCRITRATE);
+            crithitrate += GetDexCritBonus(PAttacker, PDefender);
+            crithitrate += PAttacker->getMod(Mod::CRITHITRATE);
+            crithitrate += PDefender->getMod(Mod::ENEMYCRITRATE);
             crithitrate = std::clamp(crithitrate, 0, 100);
         }
         return (uint8)crithitrate;
     }
 
+    int8 GetDexCritBonus(CBattleEntity* PAttacker, CBattleEntity* PDefender)
+    {
+        // https://www.bg-wiki.com/bg/Critical_Hit_Rate
+        int32 attackerdex = PAttacker->DEX();
+        int32 defenderagi = PDefender->AGI();
+        int32 dDex = attackerdex - defenderagi;
+        int32 dDexAbs = std::abs(dDex);
+        int32 sign = 1;
+        
+        if (dDex < 0)
+        {
+            // Target has higher AGI so this will be a decrease to crit rate
+            sign = -1;
+        }
+
+        // Default to +0 crit rate for a delta of 0-6
+        int32 critRate = 0;
+        if (dDexAbs > 39) 
+        {
+            // 40-50: (dDEX-35)
+            critRate = dDexAbs - (int32)35;
+        }
+        else if (dDexAbs > 29)
+        {
+            // 30-39: +4
+            critRate = 4;
+        }
+        else if (dDexAbs > 19)
+        {
+            // 20-29: +3
+            critRate = 3;
+        }
+        else if (dDexAbs > 13)
+        {
+            // 14-19: +2
+            critRate = 2;
+        }
+        else if (dDexAbs > 6)
+        {
+            critRate = 1;
+        }
+
+        // Crit rate delta from stats caps at +-15
+        return std::min(critRate, static_cast<int32>(15)) * sign;
+    }
+
     /************************************************************************
     *                                                                       *
     *   Formula for calculating damage ratio                                *
@@ -2326,99 +2446,204 @@ namespace battleutils
 
     float GetDamageRatio(CBattleEntity* PAttacker, CBattleEntity* PDefender, bool isCritical, float bonusAttPercent)
     {
-        // used to apply a % of attack bonus
-        float attPercentBonus = 0;
-        if (bonusAttPercent >= 1)
-            attPercentBonus = PAttacker->ATT() * bonusAttPercent;
-
-        //wholly possible for DEF to be near 0 with the amount of debuffs/effects now.
-        float ratio = (float)(PAttacker->ATT() + attPercentBonus) / (float)((PDefender->DEF() == 0) ? 1 : PDefender->DEF());
-        float cRatioMax = 0;
-        float cRatioMin = 0;
-        float ratioCap = 2.0f;
-
-        if (PAttacker->objtype == TYPE_PC)
+        uint16 attack = PAttacker->ATT();
+        // Bonus attack currently only from footwork
+        if (bonusAttPercent >= 1) 
         {
-            ratioCap = isCritical ? 3 : 2.25f;
+            attack = static_cast<uint16>(attack * bonusAttPercent);
         }
-        if (PAttacker->objtype == TYPE_MOB)
+
+        // Wholly possible for DEF to be near 0 with the amount of debuffs/effects now.
+        uint16 defense = PDefender->DEF();
+        if (defense == 0)
         {
-            ratioCap = 4.f;
+            defense = 1;
         }
 
-        ratio = std::clamp<float>(ratio, 0, ratioCap);
+        // https://www.bg-wiki.com/bg/PDIF
+        // https://www.bluegartr.com/threads/127523-pDIF-Changes-(Feb.-10th-2016)
+        float ratio = (static_cast<float>(attack)) / (static_cast<float>(defense));
         float cRatio = ratio;
-        if (PAttacker->objtype == TYPE_PC)
-        {
-            if (PAttacker->GetMLevel() < PDefender->GetMLevel())
-            {
-                cRatio -= 0.050f * (PDefender->GetMLevel() - PAttacker->GetMLevel());
+
+        // Level correction does not happen in Adoulin zones, Legion, or zones in Escha/Reisenjima
+        // Level correction is only a penalty to players, a player does not get any bonus for fighting lower level monsters
+        // Level correct does give bonuses to Monsters and Avatars. For Avatars it caps at a level difference of 38
+        // I am going to assume that the 38 level difference cap applies to monsters as well
+        // https://www.bluegartr.com/threads/114636-Monster-Avatar-Pet-damage
+        // This thread references the level correction cap for avatars and states that penalties are ignored for avatars
+        // Monster pDIF = Avatar pDIF = Pet pDIF
+        // Based on these points we know monsters and avatars ignore penalties from level correct and only get bonuses so
+        // I believe it is safe to assume all pets do this.
+
+        uint16 zoneId = PAttacker->getZone();
+        // All zones from Adoulin onward have an id of 256+
+        // This includes Escha/Reisenjima and the new Dynamis zones
+        // (Not a post Adoulin Zone) && (Not Legion_A)
+        bool shouldApplyLevelCorrection = (zoneId < 256) && (zoneId != 183);
+
+        ENTITYTYPE attackerType = PAttacker->objtype;
+
+        uint8 attackerLvl = PAttacker->GetMLevel();
+        uint8 defenderLvl = PDefender->GetMLevel();
+        uint8 dLvl = std::abs(attackerLvl - defenderLvl);
+        float correction = static_cast<float>(dLvl) * 0.05f;
+
+        // Assuming the cap for mobs is the same as Avatars
+        // Cap at 38 level diff so 38*0.05 = 1.9
+        float cappedCorrection = std::min(correction, 1.9f);
+        
+        if (shouldApplyLevelCorrection)
+        {
+            // Players only get penalties
+            if (attackerType == TYPE_PC)
+            {
+                if (attackerLvl < defenderLvl)
+                {
+                    // Screw the players, no known cap
+                    cRatio -= correction;
+                }
             }
-        }
-        else
-        {
-            if (PAttacker->GetMLevel() > PDefender->GetMLevel())
+            // Mobs, Avatars and pets only get bonuses, no penalties (or they are calculated differently)
+            else if (attackerType == TYPE_MOB || attackerType == TYPE_PET)
             {
-                cRatio += 0.050f * (PAttacker->GetMLevel() - PDefender->GetMLevel());
+                if (attackerLvl > defenderLvl)
+                {
+                    cRatio += cappedCorrection;
+                }
             }
         }
 
+        float wRatio = cRatio;
+        
         if (isCritical)
         {
-            cRatio += 1;
+            wRatio += 1;
         }
 
-        cRatio = std::clamp<float>(cRatio, 0, ratioCap);
+        float qRatio = wRatio;
+        float upperLimit = 0.0f;
+        float lowerLimit = 0.0f;
+
+        // https://www.bg-wiki.com/bg/PDIF
+        // Pre-Randomized values excluding Damage Limit+ trait
+        // Damage Limit+ trait adds 0.1/rank to these values
+        // type : non-crit : crit
+        // 1H : 3.25 : 4.25
+        // H2H & GK : 3.5 : 4.5
+        // 2H : 3.75 : 4.75
+        // Scythe : 4 : 5
+        // Archery & Throwing : 3.25 : 3.25*1.25
+        // Marksmanship : 3.5 : 3.5*1.25
+        
+        // https://www.bluegartr.com/threads/114636-Monster-Avatar-Pet-damage
+        // Monster pDIF = Avatar pDIF = Pet pDIF
 
-        if ((0 <= cRatio) && (cRatio < 0.5)) {
-            cRatioMax = cRatio + 0.5f;
+        auto targ_weapon = dynamic_cast<CItemWeapon*>(PAttacker->m_Weapons[SLOT_MAIN]);
+
+        // Default for 1H is 3.25
+        float maxRatio = 3.25f;
+
+        if (attackerType == TYPE_MOB || attackerType == TYPE_PET)
+        {
+            // Mobs and pets cap at 4.25 regardless of crit so no need to bother with crits for the max
+            maxRatio = 4.25f;
         }
-        else if ((0.5 <= cRatio) && (cRatio <= 0.7)) {
-            cRatioMax = 1;
+        else
+        {
+            // If null ignore the checks and fallback to 1H values
+            if (targ_weapon)
+            {
+                if (targ_weapon->isHandToHand() || targ_weapon->getSkillType() == SKILL_GREAT_KATANA)
+                {
+                    maxRatio = 3.5f;
+                }
+                else if (targ_weapon->getSkillType() == SKILL_SCYTHE)
+                {
+                    maxRatio = 4.0f;
+                }
+                else if (targ_weapon->isTwoHanded())
+                {
+                    maxRatio = 3.75f;
+                }
+            }
+            // Skipping Ranged since that is handled in a separate function
+            
+            // Default to 1H and check for +1 to max from crit
+            if (isCritical)
+            {
+                maxRatio += 1.0f;
+            }
         }
-        else if ((0.7 < cRatio) && (cRatio <= 1.2)) {
-            cRatioMax = cRatio + 0.3f;
+
+        // https://www.bg-wiki.com/bg/Damage_Limit+
+        // There is an additional step here but I am skipping it for now because we do not have the data in the database.
+        // The Damage Limit+ trait adds 0.1 to the maxRatio per trait level so a level 80 DRK would get maxRatio += 0.5
+        
+        if (wRatio < 0.5)
+        {
+            upperLimit = std::max(wRatio + 0.5f, 0.5f);
         }
-        else if ((1.2 < cRatio) && (cRatio <= 1.5)) {
-            cRatioMax = (cRatio * 0.25f) + cRatio;
+        else if (wRatio < 0.7)
+        {
+            upperLimit = 1;
         }
-        else if ((1.5 < cRatio) && (cRatio <= 2.625)) {
-            cRatioMax = cRatio + 0.375f;
+        else if (wRatio < 1.2)
+        {
+            upperLimit = wRatio + 0.3f;
         }
-        else if ((2.625 < cRatio) && (cRatio <= 3.25)) {
-            cRatioMax = 3;
+        else if (wRatio < 1.5)
+        {
+            upperLimit = wRatio * 1.25f;
         }
-        else {
-            cRatioMax = cRatio;
+        else
+        {
+            upperLimit = std::min(wRatio + 0.375f, maxRatio);
         }
 
-        if ((0 <= cRatio) && (cRatio < 0.38)) {
-            cRatioMin = 0;
+        if (wRatio < 0.38)
+        {
+            lowerLimit = std::max(wRatio, 0.5f);
         }
-        else if ((0.38 <= cRatio) && (cRatio <= 1.25)) {
-            cRatioMin = cRatio * (float)(1176 / 1024) - (float)(448 / 1024);
+        else if (wRatio < 1.25)
+        {
+            lowerLimit = (wRatio * (1176.0f/1024.0f)) - (448.0f/1024.0f);
         }
-        else if ((1.25 < cRatio) && (cRatio <= 1.51)) {
-            cRatioMin = 1;
+        else if (wRatio < 1.51)
+        {
+            lowerLimit = 1.0f;
         }
-        else if ((1.51 < cRatio) && (cRatio <= 2.44)) {
-            cRatioMin = cRatio * (float)(1176 / 1024) - (float)(775 / 1024);
+        else if (wRatio < 2.44)
+        {
+            lowerLimit = (wRatio * (1176.0f/1024.0f)) - (755.0f/1024.0f);
         }
-        else {
-            cRatioMin = cRatio - 0.375f;
+        else
+        {
+            lowerLimit = std::min(wRatio - 0.375f, maxRatio);
         }
 
-        float pDIF = tpzrand::GetRandomNumber(cRatioMin, cRatioMax);
+        // https://www.bg-wiki.com/bg/Damage_Limit+
+        // See: "Physical damage limit +n%" is a multiplier to the total pDIF cap. 
+        // There is one more step here that I am skipping for Physical Damage +% from gear and augments.
+        // I don't believe support for this modifier exists yet in the project.
+        // Physical Damage +% (PDL) is a flat % increase to the final pDIF cap value
+        // Meaning if a player has PDL+10% and an uppwerLimit of 1 then this would become 1.1
+        // upperLimit = upperLimit * 1.1
+
+        qRatio = tpzrand::GetRandomNumber(lowerLimit, upperLimit);
+
+        float pDIF = qRatio * tpzrand::GetRandomNumber(1.f, 1.05f);
 
         if (isCritical)
         {
+            // Crit Attack Bonus caps at +100% and is a flat increase to final crit damage
+            // so this is change to increase pDIF and not the qRatio
             int16 criticaldamage = PAttacker->getMod(Mod::CRIT_DMG_INCREASE) - PDefender->getMod(Mod::CRIT_DEF_BONUS);
+
             criticaldamage = std::clamp<int16>(criticaldamage, 0, 100);
             pDIF *= ((100 + criticaldamage) / 100.0f);
         }
 
-        //x1.00 ~ x1.05 final multiplier, giving max value 3*1.05 -> 3.15
-        return pDIF * tpzrand::GetRandomNumber(1.f, 1.05f);
+        return pDIF;
     }
 
     /************************************************************************
@@ -2431,33 +2656,33 @@ namespace battleutils
         int32 fstr = 0;
         float dif = (float)(PAttacker->STR() - PDefender->VIT());
         if (dif >= 12) {
-            fstr = (int32)((dif + 4) / 2);
+            fstr = static_cast<int32>((dif + 4) / 2);
         }
         else if (dif >= 6) {
-            fstr = (int32)((dif + 6) / 2);
+            fstr = static_cast<int32>((dif + 6) / 2);
         }
         else if (dif >= 1) {
-            fstr = (int32)((dif + 7) / 2);
+            fstr = static_cast<int32>((dif + 7) / 2);
         }
         else if (dif >= -2) {
-            fstr = (int32)((dif + 8) / 2);
+            fstr = static_cast<int32>((dif + 8) / 2);
         }
         else if (dif >= -7) {
-            fstr = (int32)((dif + 9) / 2);
+            fstr = static_cast<int32>((dif + 9) / 2);
         }
         else if (dif >= -15) {
-            fstr = (int32)((dif + 10) / 2);
+            fstr = static_cast<int32>((dif + 10) / 2);
         }
         else if (dif >= -21) {
-            fstr = (int32)((dif + 12) / 2);
+            fstr = static_cast<int32>((dif + 12) / 2);
         }
         else {
-            fstr = (int32)((dif + 13) / 2);
+            fstr = static_cast<int32>((dif + 13) / 2);
         }
         if (SlotID == SLOT_RANGED)
         {
             rank = PAttacker->GetRangedWeaponRank();
-            //different caps than melee weapons
+            // Different caps than melee weapons
             if (fstr <= (-rank * 2))
                 return (-rank * 2);
 
@@ -2478,10 +2703,31 @@ namespace battleutils
             {
                 rank = PAttacker->GetSubWeaponRank();
             }
-            // everything else
+            // Everything else
             if (fstr <= (-rank))
                 return (-rank);
 
+            // https://www.bluegartr.com/threads/114636-Monster-Avatar-Pet-damage
+            // fSTR has no upper cap for Avatars, this is likely true for monsters and all pets.
+            // Since I can only confirm Avatars and this has a much larger impact on balance I will
+            // Only change this logic for Avatars pending further testing.
+
+            ENTITYTYPE attackerType = PAttacker->objtype;
+            bool isAvatar = false;
+
+            if (attackerType == TYPE_PET)
+            {
+                if (CPetEntity* petEntity = dynamic_cast<CPetEntity*>(PAttacker))
+                {
+                    isAvatar = petEntity->getPetType() == PETTYPE_AVATAR;
+                }
+            }
+
+            if (isAvatar)
+            {
+                return fstr;
+            }
+
             if ((fstr > (-rank)) && (fstr <= rank + 8))
                 return fstr;
             else
@@ -3037,21 +3283,21 @@ namespace battleutils
             case Mod::FIREDEF:
                 *appliedEle = ELEMENT_FIRE;
                 break;
-            case Mod::EARTHDEF:
-                *appliedEle = ELEMENT_EARTH;
-                break;
-            case Mod::WATERDEF:
-                *appliedEle = ELEMENT_WATER;
+            case Mod::ICEDEF:
+                *appliedEle = ELEMENT_ICE;
                 break;
             case Mod::WINDDEF:
                 *appliedEle = ELEMENT_WIND;
                 break;
-            case Mod::ICEDEF:
-                *appliedEle = ELEMENT_ICE;
+            case Mod::EARTHDEF:
+                *appliedEle = ELEMENT_EARTH;
                 break;
             case Mod::THUNDERDEF:
                 *appliedEle = ELEMENT_THUNDER;
                 break;
+            case Mod::WATERDEF:
+                *appliedEle = ELEMENT_WATER;
+                break;
             case Mod::LIGHTDEF:
                 *appliedEle = ELEMENT_LIGHT;
                 break;
@@ -3094,12 +3340,9 @@ namespace battleutils
             * (100 + PAttacker->getMod(Mod::SKILLCHAINDMG)) / 100);
 
         auto PChar = dynamic_cast<CCharEntity *>(PAttacker);
-        if (PChar && PChar->StatusEffectContainer->HasStatusEffect(EFFECT_INNIN))
+        if (PChar && PChar->StatusEffectContainer->HasStatusEffect(EFFECT_INNIN) && behind(PChar->loc.p, PDefender->loc.p, 64))
         {
-            auto angle = PDefender->loc.p.rotation - getangle(PDefender->loc.p, PChar->loc.p);
-            // assuming default tolerance of 42 from lua_baseentity.cpp
-            if (angle > 86 && angle < 170)
-                damage = (int32)(damage * (1.f + PChar->PMeritPoints->GetMeritValue(MERIT_INNIN_EFFECT, PChar)/100.f));
+            damage = (int32)(damage * (1.f + PChar->PMeritPoints->GetMeritValue(MERIT_INNIN_EFFECT, PChar)/100.f));    
         }
         damage = damage * (1000 - resistance) / 1000;
         damage = MagicDmgTaken(PDefender, damage, appliedEle);
@@ -3502,12 +3745,13 @@ namespace battleutils
             drainPercent = drainPercent + std::min(0.02f, 0.01f * gearBonusPercent);
 
             damage += (uint32)(m_PChar->health.hp * drainPercent);
-            m_PChar->addHP((int32)(m_PChar->health.hp * -(drainPercent - m_PChar->getMod(Mod::STALWART_SOUL) * 0.001f)));
+            m_PChar->addHP(-HandleStoneskin(m_PChar, (int32)(m_PChar->health.hp * (drainPercent - m_PChar->getMod(Mod::STALWART_SOUL) * 0.001f))));
         }
-        else if (m_PChar->GetSJob() == JOB_DRK &&m_PChar->health.hp >= 10 && m_PChar->StatusEffectContainer->HasStatusEffect(EFFECT_SOULEATER)) {
+        else if (m_PChar->GetSJob() == JOB_DRK &&m_PChar->health.hp >= 10 && m_PChar->StatusEffectContainer->HasStatusEffect(EFFECT_SOULEATER))
+        {
             //lose 10% Current HP, only HALF (5%) converted to damage
             damage += (uint32)(m_PChar->health.hp * 0.05f);
-            m_PChar->addHP((int32)(m_PChar->health.hp * -0.1f));
+            m_PChar->addHP(-HandleStoneskin(m_PChar, (int32)(m_PChar->health.hp * 0.1f)));
         }
         return damage;
     }
@@ -3551,8 +3795,8 @@ namespace battleutils
     {
         if (m_PChar->objtype == TYPE_PC) // Some mobskills use TakeWeaponskillDamage function, which calls upon this one.
         {
-            // must be facing mob
-            if (isFaceing(PDefender->loc.p, m_PChar->loc.p, 23))
+            // must be in front of mob
+            if (infront(m_PChar->loc.p, PDefender->loc.p, 64))
             {
                 uint8 meritCount = m_PChar->PMeritPoints->GetMeritValue(MERIT_OVERWHELM, m_PChar);
                 // ShowDebug("Merits: %u\n", meritCount);
@@ -4065,6 +4309,7 @@ namespace battleutils
 
     void ClaimMob(CBattleEntity* PDefender, CBattleEntity* PAttacker, bool passing)
     {
+        TracyZoneScoped;
         if (PDefender->objtype == TYPE_MOB)
         {
             CBattleEntity* original = PAttacker;
@@ -4221,8 +4466,8 @@ namespace battleutils
 
     int32 MagicDmgTaken(CBattleEntity* PDefender, int32 damage, ELEMENT element)
     {
-        Mod absorb[8] = { Mod::FIRE_ABSORB, Mod::EARTH_ABSORB, Mod::WATER_ABSORB, Mod::WIND_ABSORB, Mod::ICE_ABSORB, Mod::LTNG_ABSORB, Mod::LIGHT_ABSORB, Mod::DARK_ABSORB };
-        Mod nullarray[8] = { Mod::FIRE_NULL, Mod::EARTH_NULL, Mod::WATER_NULL, Mod::WIND_NULL, Mod::ICE_NULL, Mod::LTNG_NULL, Mod::LIGHT_NULL, Mod::DARK_NULL };
+        Mod absorb[8] = { Mod::FIRE_ABSORB, Mod::ICE_ABSORB, Mod::WIND_ABSORB, Mod::EARTH_ABSORB, Mod::LTNG_ABSORB, Mod::WATER_ABSORB, Mod::LIGHT_ABSORB, Mod::DARK_ABSORB };
+        Mod nullarray[8] = { Mod::FIRE_NULL, Mod::ICE_NULL, Mod::WIND_NULL, Mod::EARTH_NULL, Mod::LTNG_NULL, Mod::WATER_NULL, Mod::LIGHT_NULL, Mod::DARK_NULL };
 
         float resist = 1.f + PDefender->getMod(Mod::UDMGMAGIC) / 100.f;
         resist = std::max(resist, 0.f);
@@ -4432,44 +4677,18 @@ namespace battleutils
     {
         if (PDefender->StatusEffectContainer->HasStatusEffect(EFFECT_BIND))
         {
-            uint16 BindBreakChance = 0; // 0-1000 (100.0%) scale. Maybe change to a float later..
-            EMobDifficulty mobCheck = charutils::CheckMob(PAttacker->GetMLevel(), PDefender->GetMLevel());
+            uint16 BindBreakChance = 950; // 0-1000 (100.0%) scale. Maybe change to a float later..
 
-            // Todo: replace with an actual calculated value based on level difference. Not it, Bro!
-            // This entire block of conditionals should not exist. Lv diff really shouldn't be handled at the exp check level either.
-            // It might not even be in sync with the check values the entire way from lv 1 to lv 99 for all we know.
-            switch (mobCheck)
-            {
-            case EMobDifficulty::TooWeak:
-            case EMobDifficulty::IncrediblyEasyPrey:
-                BindBreakChance = 10;
-                break;
-
-            case EMobDifficulty::EasyPrey:
-            case EMobDifficulty::DecentChallenge:
-                BindBreakChance = 150;
-                break;
-
-            case EMobDifficulty::EvenMatch:
-                BindBreakChance = 300;
-                break;
-
-            case EMobDifficulty::Tough:
-                BindBreakChance = 750;
-                break;
-
-            case EMobDifficulty::VeryTough:
-            case EMobDifficulty::IncrediblyTough:
-                BindBreakChance = 990;
-                break;
-
-            default:
-                // no-op
-                break;
-            }
+            // Previously there was a tiered comparative level check here which gave different rates
+            // depending on the level difference between the attacker and the defender.
+            // These rates seemed very low, and have been removed, absent true research on retail.
+            // EMobDifficulty mobCheck = charutils::CheckMob(PAttacker->GetMLevel(), PDefender->GetMLevel());
+            // The level comparison and switch has been removed.
 
             if (BindBreakChance > tpzrand::GetRandomNumber(1000))
+            {
                 PDefender->StatusEffectContainer->DelStatusEffect(EFFECT_BIND);
+            }
         }
     }
 
@@ -4625,6 +4844,23 @@ namespace battleutils
         return PSpell->getAOE();
     }
 
+    ELEMENT GetDayElement()
+    {
+        DAYTYPE weekday = (DAYTYPE)CVanaTime::getInstance()->getWeekday();
+        switch (weekday)
+        {
+            case     FIRESDAY: return ELEMENT_FIRE;
+            case    EARTHSDAY: return ELEMENT_EARTH;
+            case    WATERSDAY: return ELEMENT_WATER;
+            case     WINDSDAY: return ELEMENT_WIND;
+            case       ICEDAY: return ELEMENT_ICE;
+            case LIGHTNINGDAY: return ELEMENT_THUNDER;
+            case    LIGHTSDAY: return ELEMENT_LIGHT;
+            case     DARKSDAY: return ELEMENT_DARK;
+            default: return ELEMENT_NONE;
+        }
+    }
+
     WEATHER GetWeather(CBattleEntity* PEntity, bool ignoreScholar)
     {
         return GetWeather(PEntity, ignoreScholar, zoneutils::GetZone(PEntity->getZone())->GetWeather());
@@ -4676,55 +4912,55 @@ namespace battleutils
                         return false;
                 }
                 break;
-            case ELEMENT_EARTH:
+            case ELEMENT_ICE:
                 switch (weather)
                 {
-                    case WEATHER_DUST_STORM:
-                    case WEATHER_SAND_STORM:
-                        return true;
-                        break;
-                    default:
-                        return false;
+                case WEATHER_SNOW:
+                case WEATHER_BLIZZARDS:
+                    return true;
+                    break;
+                default:
+                    return false;
                 }
                 break;
-            case ELEMENT_WATER:
+            case ELEMENT_WIND:
                 switch (weather)
                 {
-                    case WEATHER_RAIN:
-                    case WEATHER_SQUALL:
-                        return true;
-                        break;
-                    default:
-                        return false;
+                case WEATHER_WIND:
+                case WEATHER_GALES:
+                    return true;
+                    break;
+                default:
+                    return false;
                 }
                 break;
-            case ELEMENT_WIND:
+            case ELEMENT_EARTH:
                 switch (weather)
                 {
-                    case WEATHER_WIND:
-                    case WEATHER_GALES:
+                    case WEATHER_DUST_STORM:
+                    case WEATHER_SAND_STORM:
                         return true;
                         break;
                     default:
                         return false;
                 }
                 break;
-            case ELEMENT_ICE:
+            case ELEMENT_THUNDER:
                 switch (weather)
                 {
-                    case WEATHER_SNOW:
-                    case WEATHER_BLIZZARDS:
-                        return true;
-                        break;
-                    default:
-                        return false;
+                case WEATHER_THUNDER:
+                case WEATHER_THUNDERSTORMS:
+                    return true;
+                    break;
+                default:
+                    return false;
                 }
                 break;
-            case ELEMENT_THUNDER:
+            case ELEMENT_WATER:
                 switch (weather)
                 {
-                    case WEATHER_THUNDER:
-                    case WEATHER_THUNDERSTORMS:
+                    case WEATHER_RAIN:
+                    case WEATHER_SQUALL:
                         return true;
                         break;
                     default:
@@ -5575,6 +5811,7 @@ namespace battleutils
     {
         switch (spikesType)
         {
+            // Action packet animation string order
             case SUBEFFECT_BLAZE_SPIKES:
                 return DAMAGE_FIRE;
             case SUBEFFECT_ICE_SPIKES:
@@ -5603,26 +5840,26 @@ namespace battleutils
             case ENSPELL_I_FIRE:
             case ENSPELL_II_FIRE:
                 return DAMAGE_FIRE;
-            case ENSPELL_I_EARTH:
-            case ENSPELL_II_EARTH:
-                return DAMAGE_EARTH;
-            case ENSPELL_I_WATER:
-            case ENSPELL_II_WATER:
-                return DAMAGE_WATER;
-            case ENSPELL_I_WIND:
-            case ENSPELL_II_WIND:
-                return DAMAGE_WIND;
             case ENSPELL_I_ICE:
             case ENSPELL_II_ICE:
                 return DAMAGE_ICE;
+            case ENSPELL_I_WIND:
+            case ENSPELL_II_WIND:
+                return DAMAGE_WIND;
+            case ENSPELL_I_EARTH:
+            case ENSPELL_II_EARTH:
+                return DAMAGE_EARTH;
             case ENSPELL_I_THUNDER:
             case ENSPELL_II_THUNDER:
-            case ENSPELL_ROLLING_THUNDER:
                 return DAMAGE_LIGHTNING;
+            case ENSPELL_I_WATER:
+            case ENSPELL_II_WATER:
+                return DAMAGE_WATER;
             case ENSPELL_I_LIGHT:
             case ENSPELL_II_LIGHT:
                 return DAMAGE_LIGHT;
             case ENSPELL_I_DARK:
+            case ENSPELL_II_DARK:
                 return DAMAGE_DARK;
             default:
                 return DAMAGE_NONE;